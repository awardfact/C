C언어는 1970년도 벨 연구소에서 만들어져 현재까지 사용되는 프로그래밍 언어이다 
C언어는 이후에 생긴 언어에 많은 영향을 주었다

Chapter1
 
C언어의 역사 

C언어는 UNIX운영체제의 부산물로 생성되었다 벨 연구소의 켄 톰슨, 데니스 리치등의 C언어를 만들었다 
그 당시에 다른 운영체제들은 어셈블리 언어로 만들어졌는데 어셈블리는 디버그가 힘들고 성능을 향상시키기가 매우 어려웠다
UNIX도 예외는 아니였는데 톰슨은 이러한 문제를 해결하고 UNIX를 더 발전시키기 위해 
높은 레벨의 언어가 필요하다 생각했고 그는 B언어를 디자인했다 하지만 B언어는 PDP-11에 맞지 않다고 생각했고
리치는 더 향상된 버전을 개발했다 처음에는 NEW B언어로 불렸는데 유닉스가 1973년 C언어로 재개발 되었을 때 C언어로 불리게 되었다 
C언어는 70년대에 지속적으로 발전되었다 77~79년이 특히 그런데 이 기간동안 첫 C언어 책이 나오게 되었고 C프로그래머에게
바이블이 되었다 70년대에는 C프로그래머가 비교적 적고 대부분 유닉스 유저였는데 80년대에 들어와서 C컴파일러는
다양한 운영체제에서 사용되게 되였다 특히 IBM PC플랫폼에서 빠르게 성장했다 
C언어가 유명해지고 문제가 찾아왔는데 C컴파일러는 K&R에 의지하였는데 K&R은 언어의 특징이 모호하였고 
이 특징이 자주 다르게 사용되었다 또한 K&R은 이 특징들을 명확히 하는데에 실패했다 그리고 C언어는
K&R이 쓰여진 이후에도 계속적으로 바뀌었다 새로운 특징이 추가되고 오래된 특징은 삭제되었다 
그래서 C언어에 대한 명확한 설명이 필요해졌고 1983년부터 ANSI에서 표준을 만들기 시작하였고 
1989년에 공식적으로 ANSI표준이 승인되었다 이 표준을 C89또는 C90으로 부른다 그리고 이것은 C의 오리지널 버전으로
불리는 K&R과 분리되어진다 
95년에 여러 변화가 있었고 새로운 표준이 필요해졌고 99년에 C99로 불리는 새로운 표준이 승인되었다 


C언어 기반으로 만들어진 언어

C언어는 현대 언어에 거대한 영향을 주었고 아주 많은 언어가 C언어 기반으로 제작되었는데 그 중 중요한 언어는 다음과 같다
- C++  : C언어의 모든 특징을 가지고 있고 클래스와 다른 기능이 추가되었고 객체지향 프로그래밍 언어이다
- JAVA :  C++언어 기반으로 작성되어서 C언어의 많은 특징을 가지고 있다  
- C# : C++과 자바를 기반으로 만든 더 최신 언어이다 
- Perl : 원래는 간단한 스크립트 언어였는데 성장하면서 C언어의 많은 특징을 이식하였다 
C를 배우면 C기반으로 제작된 언어들을 배울때 강력한 통찰력을 주기 때문에 첫 언어로 C를 많이 배운다
그리고 C로 작성된 많은 오래된 코드들이 있어서 C언어를 배우면 이러한 코드를 유지보수 할 수 있다 
C는 여전히 개발에 널리 사용되는 언어이다 특히 메모리가 제한된 환경에서 아주 강력하다 


C언어의 강점과 약점

C의 특징
어느 프로그래밍 언어처럼 C언어도 강점과 약점을 가지고 있다 다음은 C언어의 근본적인 특징들이다
- C언어는 로우 레벨 언어이다  : C는 기계 레벨에 접근을 제공한다 이것은 다른 언어들에게는 감춰진 것이다
또한 컴퓨터에 내장된 명령과 가까워서 프로그램이 아주 빠르다 
- C언어는 작은 언어이다 : C언어는 다른 언어들이 제공하는 특징들이 제한된다 작은 언어의 특징을 가지고 있어서
C언어는 내장된 기본 함수에 의지한다 
- C언어는 자유로운 언어이다 : C언어는 많은 것들을 허용해서 다른 언어들에 비해 자유롭다 또한 다른 언어에서 강제하는
오류확인을 강제하지 않는다 


C의 강점
효율적이다 : C는 어셈블리가 사용될 때 만들어졌기 때문에 아주 빠르고 메모리 양이 제한된다 

이식성이 좋다 : 이식성은 프로그램의 주된 목적은 아니지만 강점중 하나이다 
 프로그램은 컴퓨터에서 동작하는데 PC부터 슈퍼컴퓨터까지 범위가 다양하기 때문에 C언어를 체택하는 경우도 많이 있다
C언어의 컴파일러는 작고 쉽게 쓰여졌다 이러한 특징이 다양한 가능성을 준다 

강력하다 : C는 다양한 데이터 타입과 연산이 있어 아주 작은 코드와 라인으로도 프로그램을 만들 수 있다

유연하다 :  C는 시스템 프로그래밍을 위해 디자인되었지만 이것에 대한 제약은 없다 C는 임베디드부터 상업적 데이터
프로그램까지 모든 분야에 사용된다 

기본 라이브러리가 존재한다 : C의 강점으로 기본 라이브러리가 있는데 이 라이브러리에는 입출력, 문자열 , 저장 할당 등
여러 유용한 수백가지의 함수가 존재한다

유닉스와의 통합 : C는 특히 유닉스와 강력하게 결합된다 

C의 약점
C의 약점은 기계와 가깝다는 C의 강점에 기반하기도 한다 

에러가 생기기 쉽다 : C의 유연성은 에러를 유발하기도 한다 C컴파일러는 다른 언어의 실수를 발견하지 못하는 경우가 많다
이런 점에서 C는 어셈블리와 많이 닮아있다 대부분의 에러는 실행동안 발견하지 못해서 더 많은 문제를 야기한다 
C는 또한 부주의했을 때 눈에 안 띄는 문제를 많이 가지고 있다 

이해하기가 어렵다 :  비록 C는 작은 언어이지만 다양한 방법으로 결합되기 떄문에 타인이 이해하기 어려운 경우가 많다
C의 간결함 때문에도 문제가 방생하는데 간결함을 목적으로 만들어졌기 때문에 읽고 수정하는데 많은 시간이 걸린다 
C의 유연성도 영향을 주는데 천재들이 자기만 알아보게 코드를 작성하면 이해하는게 거의 불가능하다 

수정하기가 어렵다 : C로 작성된 큰 프로그램은 제작될 때 유지보수를 고려하지 않았다면 수정이 매우 어렵다 
현대의 프로그래밍 언어 수정에 용이한 모듈과 클래스를 제공하는데 C언어는 이런 특징이 없다 

C를 효과적으로 사용하기
C를 효과적으로 사용하려면 C의 강점을 사용하고 약점은 숨겨야 한다 

위험을 피하기 : 현대의 컴파일러는 보통 위험을 감지하는데 모든 위험을 감지하지는 못 한다 그래서 위험이 자주발생하는
코드는 주의해서 작성해야한다

소프트웨어 툴을 사용하면 프로그램이 더 신뢰성이 생긴다 :  하나의 예로 lint라는 툴이 있는데 컴파일러보다 에러를
더 잘 잡는 툴이다 또한 디버거가 있는데 C컴파일러가 버그를 잘 잡지 못하기 때문에 이러한 툴을 사용한다면
프로그램의 신뢰성이 더 올라가게 된다 

코드 라이브러리를 이용하라 : C의 강점 중 하나는 많은 다른 사람들이 만든 코드를 라이브러리로 사용할 수 있다는 것이다
잘 맞는 라이브러리를 구하면 에러를 줄이고 효과적으로 프로그램을 만들 수 있다 많은 라이브러리가 있는데
공개되어있는 오픈 소스도 있고 구매해야하는 상업적 소스도 있다

코딩 규약을 따라라 : 코딩 규약은 강제적인 규칙은 아니지만 규약을 따른다면 프로그램 만드는 데 도움이 되고 
다른 사람의 코드를 읽는데 도움이 된다 코딩 규약은 어느 언어에서도 중요하다 

혼란스럽거나 복잡한 코드를 피해라 : C는 프로그램을 만드는 데 다양한 방법이 존재하고 프로그래머는 간결한 방법을
사용하는데에 유횩되는데 가장 짧은 방법은 종종 이해하기가 제일 어려운 방법이 된다 
이해하기 쉽고 복잡하지 않게 코드를 짜야한다 

표준을 지켜라 : 대부분의 C컴파일러는 C89 , C99의 표준이 아닌 라이브러리 함수를 제공한다 
이해안되는 것을 피하기 위해서는 이러한 것들을 꼭 필요하지 않는 한 피해야한다 

chap2

pun.c
#include <stdio.h>

int main(void) {
	printf("To C, or not to C : that is the question.\n");
	return 0;
}
해당 코드에서 "include"부분은 해당 소스는 C의 표준 I/O라이브러리를 불러오는 코드이다 
그리고 "main"함수는 처음 실행하는 부분이고 무조건 있어야 하는 함수이다
printf는 표준 i/o라이브러리에 있는 함수이며 함수 안의 내용을 출력해준다  해당 함수 안의 "\n"은 다음줄로 넘어가게 해주는 코드이다
메인 함수에서 return 0;을 실행하면 프로그램이 종료된다 
그리고 파일 이름은 어느것이던지 상관이 없지만 c 확장자는 컴파일러에게 필요하다 
그리고 해당 파일을 실행하기 위해서는 기계가 실행할 수 있는 파일로 변환해야 한다 변환을 위해서는 세 스텝이 필요하다
1. 전처리  : 프로그램은 처음에 전처리기에 주어진다 전처리기는 그것을 프로그램에 추가하고 변환시킨다 
2.컴파일링 : 변환된 프로그램은 컴파일러에 이동된다 컴파일러는 이것을 기계어로 번역한다(오브젝트 코드 생성) 
3. 링킹 : 마지막 단계이다 링커는 컴파일러가 생성한 오브젝트 코드와 프로그램 실행에 필요한 추가적인 코드를 결합한다 
C언어에서 이 과정은 자동으로 진행된다 
전처리는 보통 컴파일러와 통합되어 실행된다 

컴파일, 링크 등에 필요한 명령은 컴파일러와 OS에 따라 각기 다르다 UNIX에서는 보통 cc명령을 사용한다(gcc컴파일러는 gcc) 
ex) cc pun.c
cc명령에는 다양한 옵션이 있다 대표적으로 -o가 있는데 -o뒤에 이름을 쓰면 해당 이름의 실행파일이 생성된다 
ex) cc -o pun pun.c

통합 개발환경(IDE)
이렇게 컴파일을 하려면 os에서 제공하는 시스템에 들어가서 직접 커멘드를 입력해서 실행해야하는데
IDE를 이용하면 수정,컴파일,링킹,실행,디버그 등을 한꺼번에 할 수 있다 
또한 에러가 있는 라인을 표시하여 오류도 잡을 수 있다 	


C 프로그램은 다음과 같은 형식으로 일반화할 수 있다

directives

int main(void){
	statement
}
C는 다른 언어들과 같이 { 와 } 로 시작과 끝을 나타낸다 그리고 C언어는 3가지 특징이 있는데 
지시문(directive) , 함수 (function) , 내용(statement)이다


지시문 
지시문 C프로그램을 컴파일 하기전에 전처리기에 의해 가장먼저 수정된다 
#include <stdio.h> <- 이것이 가장 기본적인 지시문이다 
이 지시문은 컴파일 하기 전에 기본 I/O라이브러리 정보를 포함시킨다 그리고 C는 이와같은 여러 헤더를 가지는데 각각 헤더는
기본 라이브러리 정보들을 포함한다 C언어는 다른 언어와 달리 내장된 입출력 능력이 없어서 기본 라이브러리의 함수를 대신 사용한다
지시문은 항상 #으로 시작한다 그리고 하나의 라인으로 구성되며 세미콜론은 필요없다 

함수 
함수는 다른 언어에서 절차나 서브루틴과 비슷하다 
함수는 두 카테고리가 있는데 프로그래머가 만든 함수와 C에서 제공되는 라이브러리 함수가 있다 
라이브러리 함수는 컴파일러와 함께 제공된다 
함수는 수학용어이기도 한데 하나 이상의 인수가 주어졌을떄 값을 계산해준다 
C에서 함수는 더 간단한데 연속된 코드가 하나로 묶이고 이름이 주어진다 
그리고 계산된 값이 주어지기도 하고 아니기도 한데 계산된 값은 return 코드로 주어진다 return은 하나만 실행된다 
C에서는 많은 함수가 있지만  main함수는 무조건 있어야한다 main함수는 프로그램이 실행될 때  자동으로 호출되고 
오직 한개의 메인 함수가 존재할 수 있다 메인함수에서 return 은 프로그램의 종료를 의미한다 
int main(void) {
	printf("To C, or not to C : that is the question.\n");
	return 0;
}
이 함수가 있을 떄 int는 해당 함수가 return할 때 어떤 형식으로 리턴을 할지를 나타낸다 void부분은 매개변수인데 
void는 매개변수가 없음을 나타낸다 그리고 메인 함수에서 리턴은 무조건 0을 해야한다 리턴이 없어도 실행은 되지만
대부분 컴파일러는 에러를 출력한다 

코드
코드는 프로그램이 실행하기 위한 명령문이다 예를들어 printf는 해당 함수를 호출하고 해당 함수는 스크린에
문자를 출력해준다 그리고 C언어는 각각 코드의 끝에 세미콜론이 있어야 한다 
컴파일러는 세미콜론을 끝으로 보기 떄문에 코드를 여러라인에 걸쳐서 작성할 수 있다 

문자열 출력
printf함수는 강력한 함수이다 "" 안에 있는 문자들을 출력해준다 
printf함수는 끝난 후에 자동으로 다음 줄로 출력을 넘기지 않는다 하나의 라인으로 사용을 하려면 \n을 포함시켜야한다
\n을 쓰면 현재 줄이 끝나고 다음줄로 넘어간다 또한 \n은 한 printf함수에서 여러번 사용이 가능하다 

주석
c프로그램에서 문서화는 아주 중요하다 모든 프로그램은 프로그램 이름, 작성일, 저자, 목적 등의 정보가 필요하다 
C에서는 /*로 시작하고 */로 끝내는  심볼을 이용해서 주석을 달 수 있다  
ex) /* this is comment */
주석은 프로그램 어디든지 작성할 수 있다 그리고 /* */ 심볼을 이용해서 주석을 달면 컴파일러는 */가 나올때까지 읽기
떄문에 여러줄에 걸처서 작성을 할 수도 있다 주석을 여러줄로 할 때 /* */만 사용하면 읽기가 어려울 수 있어서 
*로 박스를 만들어서 가독성을 높이는 방법도 있다 프로그래머는 대부분 
/*
* 내용
*/
이런식으로 가상에 별을 넣어서 주석을 만든다 그리고 주석을 끝맺지 않고 코드를 작성하면 그 코드도 주석이 된다 
C99부터는 다른 타입의 주석을 제공하는데 //로 주석을 다는것이다 
ex) // This is comment 
이 주석은 줄이 끝나면 자동으로 종료된다 여러줄에 주석을 달려면 /* */방법을 사용하거나 줄마다 //를 달아야한다 
//를 사용하면 종료를 명시할 필요가 없다는 장점이 있다 	

변수와 할당 
대부분의 프로그램을 출력을 하기전에 미리 계산을 시킨다 그리고 이것을 하기 위해서는 데이터를 일시적으로 저장할 곳이 필요하다
대부분 프로그래밍 언어에서는 변수를 이러한 저장장소로 사용한다 

타입
모든 변수는 타입을 가진다 타입은 어떤 종류의 데이터를 저장할지 명시한다 
타입은 저장할 수 있는 최소 숫자와 최대 숫자의 범위를 가진다 
int는 최대 2147483647의 범위를 가진다 
float는 더큰 숫자를 가질 수 있고 소수점도 표현이 가능하다 하지만 float는 int보다 느리다는 단점이 있다 
그리고 많은 경우에서 float는 근사치를 가지는 경우가 많다 예를들어 0.1를 저장했는데 나중에 볼떄는
0.0999999999987로 나오는 경우가 있다 

선언
변수를 사용하기 위해서는 반드시 선언을 해야한다 선언을 하기 위해서는 먼저 변수의 타입을 입력한다 
그리고 나서 변수의 이름을 입력한다 
ex) int height; float profit; 인트형으로 height변수 선언, float형으로 profit변수 선언
한번에 여러 변수도 선언이 가능하다 ( int height, length, width , volume;)
그리고 변수를 선언하는 부분과 코드부분을 빈 줄로 구분하는것이 가독성에 좋다 
변수를 코드 위쪽에 선언을 하는것이 맞지만 C99부터는 이것이 의무는 아니다 

할당
변수는 값을 할당할 수 있는데 다음과 같이 한다
ex) height = 8; length = 12; width = 10;
할당된 값은 바뀌기 전까지 지속된다 그리고 값 할당은 반드시 선언 이후에 해야한다 
그리고 float값을 할당할때는 보통 소수점을 사용한다 
ex) float profit = 2150.48;
float변수에 지속적으로 소수점을 포함하려면 끝에 f를 붙이면 좋다 (float profit = 2150.48f;)
f를 안붙이면 컴파일려가 경고를 출력한다 
한번 할당된 변수는 다른 변수 계산에 사용할 수 있다
ex) height = 8;  length = 12; width = 10; volume = height * length * width;(여기서 *는 곱하기 연산을 의미한다)

변수의 값 출력
printf함수를 이용하여 변수의 값을 출력할 수 있다 
ex)printf("Height : %d\n", height); 여기서 %d는 height값으로 대체한다 
%d는 오직 int값만 출력이 가능하다  float타입 값을 출력하려면 %f로 사용해야한다 float는 소수점 6자리까지 출력된다
소수점 자리를 설정을 하고 싶다면 다음과 같이 사용한다
ex) printf("profit : %.2f\n" , profit); 이렇게 하면 소수점 2자리수까지 출력된다 
printf에서 사용할 수 있는 변수의 개수에는 제한이 없다  
printf함수 내에서 연산해서 값을 출력할 수도 있다
ex) printf("%d\n" , height * length * width);

/는 나누기 연산을 의미하는데 나눠지는 값이 정수면 연산 결과는 소수점을 버린 정수가 나온다 

초기값 설정
어떤 변수는 자동으로 0으로 초기화 된다 그러나 대부분의 경우는 그렇지 않다 
그래서 항상 변수를 선언할 떄 값을 초기화 해주는 것이 좋다 
ex) int height = 8;  
변수를 한꺼번에 초기화는 할 수 없다
ex) int height , length , width = 10; 이렇게 하면 width만 10으로 초기화되고 나머지는 초기화되지않는다 


입력받기
scanf함수를 통해 사용자에게 값을 입력받을 수 있다 scanf는 printf와 대응되는 함수여서 구성이 비슷하다 사용은 다음과 같이 한다
ex) scanf("%d" , &i);  int값을 받아와서 i에 넣는다
%d는 printf에서와 마찬가지로 int형 값을 받는다는것을 의미한다 &i는 i의 주소를 나타낸다 
i의 주소에 int형 값을 넣는다는 것을 의미한다 floaat형은 다음과 같이 사용한다
ex) scnaf("%f", &x);  float값을 받아서 x에 넣는다 

매크로 상수 선언
매크로 상수는 선언하면 그 값은 바꿀 수 없게된다 선언은 다음과 같이 한다
#define INCHES_PER_POUND 166
#define은#include처럼 전처리기쪽에서 수행해서 세미콜론을 사용하지 않고 줄이 끝나면 명령이 끝난다 
컴파일할때 전처리기는 각각의 매크로 값을 코드에서 치환한다
ex) weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND); 여기서 매크로 상수 부분이 166으로 변한다
매크로 상수는 대문자를 사용하고 문장 사이에는_를 넣는다 

식별자
식별자는 변수, 함수, 매크로 등에 이름을 붙인것을 말한다 식별자는 알파벳, 숫자, 그리고 _ 가 들어갈 수 있다 그러나
반드시 처음은 알파벳 또는 _ 가 들어가야 한다 
ex) times10 , goet_next_char  _done 옳은 식별자 
ex) 10time  get-next-char  옳지 않은 식별자( 숫자가 맨 앞, 들어올 수 없는 문자가 들어감)
그리고 C는 대문자와 소문자가 구별이 된다 그래서 아래는 모두 다른 식별자이다
ex) job joB jOb jOB Job JoB JOB JoB
C프로그래머가 식별자 이름을 지을때 관례가 있는데 하나는 _로 구분을 하는것이다
ex) symbol_table current_page name_and_address(스네이크 표기법)
그리고 하나는 대문자로 구분을 하는 것이다
ex) symbolTable currentPage nameAndAddress(카멜표기법)
키워드는 식별자의 이름으로 사용할 수 없다 다음은 C에서 사용하는 키워드들인데 식별자로 사용할 수 없다

키워드
auto	enum	restrict(C99부터)	unsingned	break
extern	return	void	case	float	short	volatile
char	for	signed	while	const	goto	sizeof
_Bool(C99부터)	continue	if	static	_Complex(C99부터)
default	inline(C99부터)	struct	_Imaginary(C99부터)    do
int	switch	double	long	typedef	else	register	union


C프로그램 배치
C프로그램은 연속적인 토큰으로 구성되는데 식별자나 키워드는 그 의미를 바꿀 수 없다 
+, - 나 ; 같은 printf함수를 호출하는 코드가 있을 떄 항목은 7개로 나눌 수 있다
ex) printf - 1번째토큰  ( - 2번째 토큰  "Height : %d\n" - 3번쨰 토큰   , - 4번째 토큰  height - 5번쨰 토큰 ) -6번쨰 토큰 ; - 7번째 토큰
여기서 1,5번은 식별자이고 3번은 문자열 2,4,6,7은 구두점에 해당된다 토큰들 사이의 공간은 대부분의 경우에는 
크게 의미가 없다 하지만 가독성을 위해서는 적절한 공간이 필요하다 
토큰 사이의 스페이스,  탭, 줄바꿈 등을 사용하는 규칙은 프로그램 배치에 아주 중요하다 
1. 코드를 한줄로 하기가 너무 길어 한줄로 하기 어려우면 여러 라인으로 나눌 수 있다
2. 토큰 사이의 공간은 가독성에 좋기 때문에 각각 연산 사이에는 공간을 두는것이 좋다 
3. 들여쓰기는 블럭 공간을 구성하기에 좋다 
4. 비어있는 줄은 프로그램 구조를 보기 쉽게 만들어준다 
토큰 내에서 공간을 주면 프로그램 오류를 유발할 수 있다 그리고 문자열 사이에 줄바꿈을 하면 오류가 생긴다
  

GCC컴파일러  
GCC컴파일러는 GNU 에서 만든 C언어 컴파일러이다 GCC컴파일러를 사용하면 여러 옵션을 사용하여 잠재적 문제가 발생하는 부분 등 철처하게
프로그램을 체크할 수 있다 대표적인 옵션은 다음과 같다
-WALL : 잠재적 에러에 대한 위험 메시지를 출력한다 -O옵션과 같이 사용하면 효과가 좋다
-W :  -Wall옵션이 생성한 것에 더해서 추가적인 위험 메시지를 출력하다 
-pedantic  :  C표준이 아닌 코드에 대해 위험을 감지한다
-ansi : GCC표준을 켜지 않아서 원래 안되는 몇몇 특징을 가능하게 하다 
-std=c89 , -std=c99 : 버전을 명시해서 C컴파일러가 프로그램에서 사용할 수 있게 한다 
이러한 옵션들은 조합해서 사용된다
ex) gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c

main함수에서 리턴 부분에 return 0와 exit(0)은 동일한 기능을 한다 
main함수에서 리턴 부분은 의무는 아니고 C89부터는 없어도 종료는 된다 C99부터는
return부분이 없으면 프로그램은 자동으로 0을 리턴한다 

주석 부분을 종료하지 않으면 컴파일이 되지 않는다 주석을 종료하지 않는 부분이 프로그램을 이상하게 만들기 때문이다
주석을 종료하지 않으면 그 부분이 강조되서 그 부분을 고치면 된다
/* */이 주석안에 /* */주석을 넣으면 오류가 발생한다 */이 부분이 종료가 되기 때문이다 

float값 뒤에f를 붙이지 않으면 double타입으로 인식을 하기 때문에 범위가 훨신 커지게 된다 

C89부터 식별자 이름의 길이에는 제한이 없다 하지만 컴파일러는 처음 31자만 인식을 하기 때문에 처음 31(C99부터는 63자)자가 같으면
같은 식별자로 인식을 한다 그리고 오래된 linker를 하용하면 처음 6자리만 인식을 하게 된다 (대부분 컴파일러는 이부분을 무시해도된다)

chap3  

printf함수
printf함수는 문자를 화면에 보여주도록 디자인되었다 printf함수는 반드시 서식 문자열이 있어야 한다 
그리고 서식 문자열에 변수 출력 형태를 넣으면 넣으면 뒤에 변수를 넣어야한다
ex)printf(string, expr1, expr2,...);
값에는 변수, 상수 ,복잡한 표현등이 들어갈 수 있고 숫자에는 제한이 없다 
서식 문자열에는 평범한 문자와 %로 시작하는 전환되는 문자가 올 수 있다 이것은 뒤에 넣는 값으로 대체가된다
또한 %뒤에오는 형식에 맞는 값이 와야한다 
C컴파일러는 printf 서식 문자열에 있는 %로 시작하는 문자의 개수와 뒤에 오는 값의 개수 숫자를 체크하지 않는다
%를 1개 쓰고 뒤에 2개가 왔을 떄 뒤에것은 출력이 되지 않고 %을 2개 쓰고 뒤에 1개가 왔을 떄는 의미없는 값이 출력된다 
타입에 맞지 않는 값이 와도 의미없는 값이 출력된다 

변환지시어 
변환지시어는 프로그래머에서 컨트롤할 수 있는 강력한 힘을 주지만 복잡하고 읽기가 힘들다 
%뒤에는 많은 옵션이 있다 
ex) %m.pX    %-m.pX 이런식으로도 올 수 있는데 m과 p는 숫자로 들어가고 옵션이다 X는 문자형식이 들어가고 필수로 들어가야한다   
ex) %10.2f  여기서 m이 10이고 p가 2 X가 f가 된다  %.2f가오면 m은 없는거고 p가 2 X가 f이다
m은 최소 길이를 나타낸다 10이 들어가면 최소 10자리가 확보가 되는 것이다 그리고 입력한 숫자가 값이 자리보다 크다면
오른쪽부터 채워진다 
ex) %4d  , 123 이렇게 했을 때 0123  ( 0은 빈칸) 이렇게 채워진다 
자리수가 입력한 숫자보다 크면 자동으로 확장된다 그리고 앞에 -를 붙이면 오른쪽부터 채워지는 것이 아니라 왼쪽부터 채워지게 된다
ex) %-4d , 123 이렇게 입력했을 때 1230 (0은 빈칸)이렇게 채워진다 
p는 X가 소수점 형식일 떄 소수점 몇자리까지 오는지를 입력하는 곳이다 
ex) %.2f , 12.111111111이렇게 온다면  12.11이렇게 출력이 된다 
X는 전환되는 형식을 나타낸다 자주 사용하는 형식은 다음과 같다
-d  : int형식을 10진수 형식으로 출력한다 
-e : float 형식의 숫자를 지수 형식으로 출력한다 p는 소수점 뒤에 얼마나 많은 숫자를 표시할지를 나타낸다 기본값은 6이다 0이면 
소수점 자리가 표시되지 않는다 
-f : float 형식을 부동 수수점 형식으로 출력한다 p부분은 e와 같다
-g : float형식을 부동소수점 또는 지수형식으로 출력하는데 숫자의 크기에 따라 달라진다 숫자의 범위가 작으면 f 크면e형식으로 출력

확장열
\n은 서식 문자열에서 자주 사용되는 코드의다 확장열이라 불리는데 출력되지 않고 줄바꿈 등 특별한 기능을 수행한다 
대표적인 확장열은 다음과 같다
Alert(bell) : \a  경보가 울린다 
Backspace : \b    뒤로 한칸 이동한다  
New line : \n   줄바꿈을 한다 
Horizontal tab : \t    수평탭 간격을 띄운다 
"출력   : \"   큰따옴표 출력 
\출력 : \\    \출력 
%출력 : %% 

scanf함수
scanf함수는 특정 형식을 불러오는 함수이다 서식 문자열에는 일반 문자와 변환 지시어가 오는데 
변환 지시어의 사용 방식은 printf와 동일하다 대부분은  변환지시어만 사용한다 
scanf도 printf처럼 부주의 했을 때 함정에 빠질 수 있는데 변환 지시어와 뒤의 값 개수가 같아야 하고
적절한 값이 와야한다 또한 &를 사용해야한다 &는 변수의 주소를 의미한다 
&를 사용하지 않으면 주소에 들어있는 값의 주소에 값을 넣기 때문에 오류가 발생한다 
scanf는 강력하지만 아주 힘든 읽는 방법이다 

scanf가 동작하는 방식
printf와 마찬가지로 scanf는 서식문자열을 다룬다 함수가 호출되면 문자열의 왼쪽부터 정보를 읽는다 
그리고 빈칸을 스킵하고 적절한 문자열의 위치를 찾아낸다 그리고 적절하지 않은 문자가 올때까지 입력을 읽는다
그리고 남은 서식문자열이 있으면 계속 진행한다 읽는데에 실패하면 남은 서식문자열이 있어도 즉시 반환한다 
scanf는 공백을 무시한다(스페이스, 세로또는 가로 탭 , 줄넘김 등) 결과적으로 한줄에 여러개 또는 여러 라인으로
값을 받아올 수 있다
ex) scanf("%d%d%f%f", &i ,&j ,&x , &y); scanf가 이렇게 되어있을 때
   1  
-20     .3  
   -4.0e3  이런 입력이 와도 공백은 무시되기 떄문에 정상적으로 읽는다
int를 읽을 때 처음으로 보이는 숫자를 찾고 숫자가 아닐떄까지 읽는다 
입력을 지수형식으로 할 수도 있다 

서식 문자열의 평범한 문자
빈 문자 : scanf에서 공백을 만나면 공백이 아닌 문자가 올때까지 읽는다 그래서 한개 이상 공백은 의미는 없다 
다른 문자 : 서식 문자열에서 공백이 아닌 문자를 읽으면 scanf는 입력받은 다음 문자열과 비교한다
만약 같으면 그 입력은 버려진다 그리고 서식 문자열은 계속 이런 과정을 반복한다 
두 문자가 같지 않으면 scanf는 입력에 놓는다 
ex) 서식문자열 - "%d/%d"일떄 입력으로 05/096을 입력하면 
scanf는 처음 공백을 스킵하고 %d로 5를 읽는다 그리고 /는 서식 문자열에 있는 /떄문에 스킵되고 두번쨰 %d로 96을 읽는다
만약 050/096을 입력했다면 5는 정상적으로 들어오는데 /이 와야하는곳에 공백이 와서 두번째 %d로 /096을 읽어버리게 된다
이 입력이 정상적으로 되게 하려면 "%d /%d" 서식문자열을 이렇게 해야한다 

printf와 scanf의 혼란
printf와 scanf함수는 상당히 유사해보이지만 상당한 차이가 있다 차이점을 무시하고 프로그램을 짜면 매우 위험하다
예를들어 printf의 변수가 오는 곳에 &변수명 이렇게 하면 잘못된 코드가 된다 반대로 scanf에 &를 넣지 않으면 잘못된 코드가 된다 
그리고 scanf를 scanf("%d, %d", &i, &j); 이렇게 했을 때 처음 숫자 뒤에 콤마가 아닌 공백이 오면 j를 읽지않고 종료가 된다
그리고 scanf에 확장열을 사용하면 동작은 하지만 좋지 않은 코드가 된다 

%d대신에 %i를 사용할 수도 있는데 %i를 사용하면 8진수 또는 16진수가 올 수가 있다 
숫자앞에 0이 있으면 8진수 0x가 있으면 16진수로 판단한다 


chap4  (Expressions)

가장 심플한 표현은 상수와 변수이다 변수는 계산된 값을 나타낸다 그리고 상수는 변하지 않는 값을 나타낸다 
더 복잡하게 가면 연산자와 피연산자가 있다 
ex) a + (b *c)의 식이 있을때 +는 연산자고  a,b,c는 피연산자다 
C언어에서는 다른 언어에서도 찾을 수 있는 기본적인 연산자를 제공한다 
-산술 연산자 (+ / 등등)
-관계 연산자 (값을 비교하는)
- 논리 연산자
이것들 말고도 연산자가 다수 존재한다 다른 연산자들도 알면 좋지만 이 연산자들을 능숙히 다루는 것이 우선이다 

산술 연산자 
산술 연산자에서 더하기, 뺴기 , 곱하기 , 나누기가 있다 

단항연산자 		이항연산자
+(단항이 +인지)		+(더하기)        *(곱하기) 
- (단항이 -인지)		-(뺴기) 	        /(나누기)
				       %(나머지)
단항연산자의 예는 다음과 같다
ex) +1  , -i    +단항연산자는 의미는 없다 -는 음수를 나타낸다
그리고 이항연산자는 %빼고는 친숙한 연산자들이다 %연산자는 두 수를 나누고 몫이 아닌 나머지를 계산한다 
int형과 float형을 피연산자로 연산을 하면 결과는 float가 나온다 
int형끼리 /연산을 했을 떄 정수형으로 결과가 나와서 소수점은 버려진다 ex) 1/2 = 0
%연산자는 정수형 피연산자가 필요하다 없으면 컴파일이 안된다 
/연산 , % 연산에서 오른쪽 피연산자에 0을 넣으면 아무 행동도 하지 않게된다
C89까지 %와 /연산은 값이 정확하지 않은 나쁜 연산이였는데 C99부터는 이것이 해결되었다 

연산자 결합과 우선순위
연산자가 다중으로 사용되면 어떤식으로 결합되는지 이해하기가 어렵다 그래서 C언어에는 연산자마다 우선순위가 존재한다

가장우선   +   - (단항)
	*      %
가장안우선     + -  (이항)
같은 라인에 있는것들은 같은 우선순위를 가진다 
이런 우선순위가 있어서 연산이 많아도 어떤 연산부터 진행할지 알 수 있다
그리고 같은 우선순위의 연산자가 많이 있다면 이항 연산은 왼쪽부터 우선적으로 결합되어 연산이 진행된다
ex) i - j - k   =  (i -  j) - k
단항 연산은 오른쪽부터 우선으로 진행된다
ex)   - + i    =   - (+i)


지정 연산자 
계산을 하면 계산 한 것을 나중에 사용하기 위해 집어넣은 공간이 필요하다  C는 =(지정연산자)를 통해 이 역할을 수행하는데
지정연산을 사용하면 이미 저장되어있는 값이랑 상관없이 값을 갱신해준다 

간단한 지정
v = e  의 방식으로 지정 연산자를 사용하면 e에있는 값이 복사되어서 v변수에 들어간다 
ex) i = 5; j = i;    k = 10 * i + j;
만약 v와 e가 같은 타입이 아니라면 e의 타입이 v의 타입으로 변환되어서 들어간다 
ex)int  i = 72.99f  (i에는 72가 들어간다)     float f = 136(f에는 136.0이 들어간다)
지정연산자는 연쇠적으로도 사용할 수 있다 
ex) i = j = k = 0  지정 연산자는 오른쪽부터 진행하기 때문에 0이 k, j, i에 들어간다 
지정 연산자는 공간의 제약이 없어서 다양한 방법으로 사용이 가능하다 
ex) i = 1;  k = 1 + ( j = i)     이렇게 하면 j에는 1이 들어가고 1+1이여서 k에 2가들어간다
			
Lvalues
연산은 변수 상수등 피연산자와 함게 사용한다 하지만 지정연산자는 좌측의 피연산자는 반드시
메모리에저장할 수 있어야 한다 또한 좌측의 피연산자에는 다른 식이 올 수 없다 
ex) 12 = i;   i + j = 0;    -i = j  이러한 연산은 잘못된 연산이 된다 
이러한 연산이 오면 컴파일러가 오류를 알린다

복합대입연산자(compound assinment)
지정연산을 사용할 떄 오래된 값을 사용한 연산을 통해 새로운 값을 만드는 경우가 많다 
EX)  I = I + 2;
C에서 복합대입연산자를 사용하면 코드를 짧게 쓸 수 있다 
ex) i +=2;   위에 있는 i = i + 2;와 동일하다 
+=이외에도  -= %= /= *=도 사용이 가능하다 
- v += e   :  v와 e를 더한 값을 v에 넣는다
- v -= e   : v에서 e를 뺀 값을 v에 넣는다
- v *= e  :   v와 e를 곱한값을 v에 넣는다 
- v /= e :   v에서 e를 나눈값을 v에 넣는다
- v %= e  : v에서 e를 나눈 나머지를 v에 넣는다 
복합대입연산자는 풀어서 연산한것과 완전히 동일하지는 않는다 드문 경츠우로 
v += e 와   v = v + e는 다른 결과가 나온다 
복합대입연산자를 연쇄적으로 사용하면 다음과 같이 동작한다
ex)  i += j += k;    는     i += (j += k);이렇게 동작한다 

증감연산자
변수에 1을 더하고 빼는 연산은 아주 자주 사용하는데 이것을 간단히 사용하는 방법이 증감연산자를 사용하는것이다
++ 와 -- 를 사용하는것인데 해당 연산을 변수와 함께 사용하면 변수의 값을 1 증가 또는 감소시킬 수 있다
주의할 점은 증감연산자의 위치이다 변수 앞에 쓰냐 뒤에 쓰냐에 따라 값이 달라질 수 있다
ex) i = 1  printf("%d",  ++i);   printf("%d", i); 이렇게 앞에 증감연산자를 쓰면 첫printf때 값이 증가돼서 2가 출력된다(값을 증가시키고 나머지 연산 실행)
ex) i = 1 printf("%d", i++); printf("%d",i)이렇게 증감연산자를 뒤에 쓰면 첫 printf때는 값이 1 출력이 된다 하지만 
두 번쨰 printf에는 2가 출력된다 뒤에 증감연산자를 사용하면 값을 증가시키지 않고 나머지 연산을 수행하고 수행 수 값을 증가시킨다
앞에 증감연산자를 쓰면 즉시 값을 증가시키고 뒤에 증감연산자를 쓰면 오래된 값을 사용하고나서 값을 증가시킨다

수식 순서

순위 	이름		심볼		방향
1	증감(후)		++		왼쪽에서 오른쪽
	감산(후)		--		왼쪽에서 오른쪽
2 	증감(선)		++		오른쪽에서 왼쪽
	감산(선)		--		오른쪽에서 왼쪽
	단항 +		+		오른쪽에서 왼쪽
	단항 - 		- 		오른쪽에서 왼쪽
3	곱하기 나누기	*, /,  %		왼쪽에서 오른쪽
4	더하기빼기	+ , -		왼쪽에서 오른쪽
5	할당연산		=, +=, /=		오른쪽에서 왼쪽
이 표는 연산사이의 순서와 연산 방향을 나타낸다 

하위표현식 순서
하위표현식의 순서를 나타내는 규칙은 따로 없고 어느 순서로 해도 대체로 맞지만 아닐때가 있다 
c = (b = a + 2 ) - ( a = 1); 이런 식이 있을 때 C는 어떤일이 일어날지 말해주지 않는다 
대부분의 컴파일러는 6또는 2를 출력하는데 어떤 식이 먼저 실행되느냐에 따라 달라진다 
이런 것을 막기 위해서 하위표현식의 순서를 피하는 것이 좋다 
ex) a = 5;  b = a + 2;  a = 1; c = b- a;
가감산 연산을 동시에 포함하는 연산에서도 이런 문제가 발생한다 
ex) i = 2; j = i  * i++; 보통 j의 값으로 4를 예상하지만 4가 올수도 있고 6이 올수도있다

표현식 문(Expression Statement)
C에서는 어떤 표현식이든 문이 될 수 있다  ++i;의 문이 실행될 때 i는 값이 증가하고 i에 들어간다
하지만 ++i는 더큰 표현식이 아니다 이 값은 다음 문이 실행될때 버려진다(i값은 변한다)
ex) i = 1;  i--;  i * j - 1;   이 3가지 문이 있을 때 마지막 문은 아무런 영향을 끼치지 않는다 

%연산은 정수끼리 연산만 가능하지만 fmod함수를 사용하면 실수도 가능하다 
v += e 와 v = v + e의 차이점은 v+=e는 딱 한번만 계산하지만 v = v + e 는 두번 계산한다는 점에서 차이가 있다
a[i++] +=2;      a[i++] = a[i++] + 2; 이 두 식이 있다고 했을 때 끝나고 난 후의 i값을 다르게 된다
현대의 C에서는 -- 또는 ++ 연산이 더 빠르지 않지만 간편하고 편해서 자주 사용한다
++또는 -- 연산은 float에서도 사용이 가능하다 
후위 가감산 연산은 sequence point라는 개념이 있는데 이전 sequence point와 다음 sequence point사이에서 일어난다

chap5  selection Statement(조건문)

프로그램을 짜다보면 retrun문을 실행할지 다른 표현식을 사용할지에 대해 직면한다 대부분의 경우에는
실행 순서에 미치는 영향에 따라 3가지 카테고리중에 사용한다 
조건문(selection statement) : if문과 switch문이 있고 선택 가능한 것들 중에 특정 문을 실행한다 
반복문(iteration statement) : while문과 for문이 있고 반복을 지원한다
분기문(jump statement) :  break, continue , goto 문이 있고 프로그램의 다른 위치로 이동을 시켜준다 

논리 표현식(logical expressions)
많은 C문에서 if문을 포함하는데 반드시 true또는 false값이 있어야한다 
i< j가 있을 때 해당 식은 Boolean또는 논리 타입(0-false  1-true)을 반환한다 

관계연산자(Relational Operators)
C의 관계연산자는 수학에서의 < > 등 관계연산자와 일치한다 결과값으로 0또는 1를 생산한다는 것을 뺴고
ex) 10 < 11은 1을 생산하고   11< 10 은 0을 생산한다
관계연산자는 다음과 같다
심볼		뜻
<		더 작다
>		더 크다
<=		더 작거나 같다
>= 		더 크거나 같다
관계연산자는 정수형 실수형을 동시에 사용할 수 있다
관계연산자의 우선순위는 계산 연산자들보다 순위가 낮다
ex) i + j < k -1   =   (i + j) < ( k -1 )
관계 연산자는 왼쪽부터 실행한다
ex) i < j < k = (i < j)  < k    이 식은 변수들의 크기를 비교하지 않는데 처음 연산으로 1 또는 0이 나오기 때문이다

동등 연산자(Equality Operators)
동등연산자는 다음과 같다
심볼		뜻
==		같다
!= 		같지 않다
관계 연산과 같이 동등 연산자도 왼쪽부터 실행하고 0 또는 1을 결과값으로 가진다 하지만 
동등연산자는 관계연산자보다 우선순위가 낮다
ex) i < j == j < k     =    (i < j) ==  (j < k)

논리 연산자(Logical Operators)
복잡한 논리 표현식을 논리 연산자로 간단히 할 수 있다  논리 연산자는 다음과 같다
심볼		뜻
!		논리 부정(단항연산자)
&&		논리곱(이항연산자)
||		논리합(이항연산자)
논리 연산자의 결과로 0 또는 1의 값이 나온다 그리고 피연산자의 값도 0인지 아닌지를 판단한다 
ex) !expr 의 값이 1이면 expr은 0이다   ,   expr1 && expr2의 값이 1이면 expr1, expr2둘다 0이 아니다
expr1 || expr2의 값이 1이면 둘중 하나는 0이 아니다
논리 연산자를 실행할 때 왼쪽 피연산자부터 계산하고 오른쪽 피연산자를 계산한다 
왼쪽 피연산자를 계산했을 때 이미 결과가 나오면 오른쪽 피연산자는 계산하지 않는다
ex) (i != 0 ) &&  (j / i > 0) 의 연산이 있을 떄 i != 0의 결과로 0이 나오면 오른쪽 피연산자의 값이 어떻든 0이 나오기 떄문에 계산하지 않는다
논리 연산에서 이것과 관련해서 주의해야하는 것이 있는데
ex) i > 0  && ++j > 0 이 식이 있을 때 왼쪽 피연산자의 결과로 0이 나오면 오른쪽은 계산을 하지 않기 떄문에 j는 증가하지 않는다 
!연산은 단항 + - 와 같은 우선순위를 가지며 오른쪽부터 실행하고    && 와 ||는 관계연산, 동등연산자보다 우선순위가
낮고 왼쪽부터 실행한다 

if문
if문은 표현식의 값에 따라  두 대안을 골라서 실행한다 if문은 다음과 같은 형태를 가진다
ex) if (expression)  statement
expression은 무조건 있어야 한다 expression값이 0이 아니면 statement를 실행한다
ex) if( line_num == MAX_LINE) line_num = 0;  여기서 line_num== MAX_LINE의 값이 0이 아니면 line_num = 0;을 실행한다 
지정연산자와 동등연산자를 혼동해서는 안된다 지정연산자를 사용하면 항상 0으로 판단한다

복합문
if문에 statement를 여러 개 넣고 싶다면 statement를  중괄호( {와 } ) 로 감싸면 된다 
이렇게 중괄호로 감쌀 때 보통 statement는 여러줄에 걸쳐서 사용을 한다
ex) 
{
  line_num = 0;
  page_num++;
}

else절
if문은 else절과 함께 사용이 가능하다 사용 형태는 다음과 같다
ex) if(expression) statement  else  statement
여기서 else에 있는 문은 표현식의 값이 0일떄 실행된다 
ex) 보통 if, else문은 다음과 같이 사용한다
if(i > j)
  max = i; 
else 
  max = j;
짧게 사용하기 위해서 다음과 같이 작성하기도 한다
if(i>j) max = i;
else max = j;

if문 내부에 if를 쓰는 등 내부문에는 제약이 없다 
ex) if(i > j){
       if(i > k){
	max = i;
       }else {
	max = k;
      }
   }else{
     if(j > k){
	max = j;
     }else{
    	max = k;
     }
}

다단계 if문( cascade if statement)
다단계 if문은 다음과 같이 사용한다
if(expression)
  statement
else if(expression)
  statement
....
else
  statement
여기서 마지막 else문은 필수는 아니다 
다단if문을 사용할 떄 else가 어떤 if문을 사용해야 하는지 모호한 문제가 발생할 수 있는데
ex) if (y != 0 )  if( x != 0 ) result = x/y;  else printf();
C언어에서는 esle문은 가장 가까운 if문을 따른다 더 명확히 하기 위해 중괄호를 사용하면 알기가 쉬워진다

조건 표현식(Conditional Expression)
C의 if문은 조건에 따라 1개나 2개의 액션을 취하는데 C는 이런 1개나 2개의 값에 의존하는 조건식을 제공한다
조건표현식은 다음과 같이 사용한다
ex) expr1 ? expr2 : expr3  expr들은 어느 타입의 표현식도 가능하다 
이 표현식을 사용하려면 피연산자가 3개가 필요하기 때문에 삼항연산자라고도 부른다 
expr의 결과가 0이 아니면 expr2 0이면 expr3을 반환한다 
우선순위는 대입 연산자보다는 높지만 다른 연산보다는 낮다

C89에서 boolean값
오랜시간동안 C는 적절한 Boolean타입이 없었다 그래서 프로그래머들은 참과 거짓을 표현하는 다양한 방법을 
사용하였다 
ex) int flag; flag = 0;  flag = 1;    또는 #define TRUE 1  #define FALSE 0
여기서 더 나아가 타입을 만들어서 사용하였다
ex) #define BOOL int   BOOL flag;

C99에서 boolean값
오랜기간동안 C에서 boolean자료형은 없었는데 C99부터 _Bool 타입을 제공하였다 
ex) _Bool flag;
_Bool은 int타입이지만 오직 0과 1만 올 수있다 다른값을 넣어도 1으로 변환된다
C99에서는 또한 <stdbool.h>라는 새로운 헤더를 제공한다 이 헤더는 매크로 bool등을 제공하는데
이것을 사용하면 쉽게 bool변수를 사용할 수 있다
ex) bool flag  (_Bool과 동일)   flag = false;  flag =true;

switch문
다중 if문을 사용하여 구현하는 것을 switch문으로 대체해서 구현이 가능하다 
ex) 왼쪽 다중 if문을 사용한 것을 switch문을 사용하면 아래와 같다 
if(grage == 4){           switch(grade{
  print();			case 4 :  print; break;
 }else if(grade == 3){   	case 3 : print; break;
  print();			case 2 : print; break;
}else if(grade == 2){ 	case 1 : print; break;
}else if(grade == 1){ 	case 0 : print; break;
}else if(grade == 0 ){ 	default: print; break;
}else{ print }		}
해당 switch문이 실행되면 grade가 4,3,2,1,0인지 체크해서 맞으면 case내부의 문을 실행하고 break를 만나면 switch가 종료된다
grade가 맞는 값이 없으면 default의 문이실행된다 복잡한 경우에서 switch문은 다중 if문보다 읽기가 쉽고 더 빠르다 
일반적은 switch문은 다음과 같이 구성된다
switch(expression){
  case constant-expression : statement
...
  case constant-expression : statement
  default statement }
switch에서 표현식은 반드시 정수가 와야한다 char도 C에서는 정수로 표현되기 때문에 사용이 가능하다 float나 string은 안된다
case로 시작하는 case-label이 있는데 constant-expression은 일반표현식이지만 변수나 함수등이 올 수 없다 반드시 정수나 문자가 와야한다
case label뒤에는 문이 오는데 문의 숫자는 제한이 없고 중괄호도 필요없다 보통 마지막 문에는 break를 사용하는데
필수가 아니다 break가 없으면 다음 case-label이 실행된다 
case label을 복사하는것은 허용이 안되며 순서는 상관이 없다 default도 마지막에 올 필요는 없다
여러개의 case label이 같은 문을 사용할 수도 있다
ex) switch (grade) { case 4 : case 3 : case 2 : case 1 : printf() break; case 0 : printf() break; default print(); break;
위와 같이 사용하면 4 ,3 ,2 1일떄 동일한 문을 사용한다 범위는 지정이 불가하다 
default를 사용하는 것도 선택이기 때문에 무조건 넣을 필요는 없다 

break문의 역할 
switch에서 break문을 사용하면 switch다음 구문으로 이동을 한다 
break가 필요한 이유는 break를 사용하면 계산된 곳으로 점프를 하기 떄문이다 switch문에서 break문이없다면
expression의 case label부터 마지막 case label까지 모두 실행된다 
의도적으로 break를 안쓰는 경우는 드물기 때문에 안쓰는 경우에는 주석을 다는것이 좋다 마지막 case label은
break는 필요하지 않지만 나중에 추가될 수도 있기 때문에 break를 쓰는 것이 좋다 

조건 표현식에서 값에 float와 int가 섞여있으면 조건표현식의 자료형은 float가 된다 
(i > 0 ? i : f)여기서 i가 int f가 float고 i가 0보다 큰 경우에 반환되는 i의 자료형의 float이다 


chap6 Loops

반복문은 어느 문들을 반복해서 실행하는데 반복마다 조건식이 필요하다 조건식이 0이 아니면 반복을 지속한다
C의 반복문에는 while, do while, for문이 있다 

while문
C에서 while문은 가장 간단하고 기본적인 반복문이다 형태는 다음과 같다 
ex) while(expression) statement
표현식 내부네은 조건식이 들어가는 경우가 많고 statement는 반복하는 대상이다 
while문이 시작할 때 조건식을 먼저 보고 그 값이 0이 아니면 반복 대상을 실행한다 그리고 이것을 반복한다 
반목 대상을 중괄호로 감싸면 반복 대상의 길이에는 제한이 없어진다 

무한반복(Infinite Loops)
while문의 조건식이 항상 0이 아닌 수가 나오면 while문은 종료가 되지 않는다 때때로 C프로그래머들은 의도적으로 
무한반복문을 만든다 
ex) while(1) .... 이렇게 무한으로 반복을 돌게 만들면 반복을 빠져나오는 문을 만나지 않는이상 계속 반복된다(break, goto, return)

do while문
do문은 while문과 밀접하게 연관되어있다  형태는 다음과 같다
ex) do statement while(expression);
여기서 statement문이 먼저 한번 실행되고 그 다음에 조건식을 계산한다 조건식이 0이 아니면 statement문을
실행하고 이를 반복한다 do문은 이 조건식이 0이 나오면 종료된다

for문
for문은 카운팅을 하는 반복문에서 이상적인 형태이다 for문의 형태는 다음과 같다
ex) for(expr1; expr2; expr3) statement
for문을 while문으로 바꾸면 다음과 같다
ex) expr1;  while(expr2) { statement  expr3;} 
이 패턴을 보면 expr1은 초기값을 설정하고 한번만 실행된다 expr2는 반복의 종료조건이 들어가고 expr3은
각 루프의 끝에 실행되는 연산을 의미한다  
expr1과 expr3은 필수로 들어가야 하는 식은 아니다 그리고 expr3식에는 보통 가감산 연산을 주로 사용한다(++ --)

for문의 특성(idioms)
for문은 숫자를 증가시키거나 감소시키는 반복에서 사용하기 좋은 반복문이다 n번 반복하는 형태는 다음과 같다
0부터 n-1까지 반복
for(i = 0; i < n; i++) ...
0부터 n까지 반복 
for(i = 0; i <=n; i++)...
n-1부터 0까지 반복
for(i = n -1; i >= 0; i++)..
n부터 1까지 반복
for(i = n; i >0; i++)...
이 형태를 복사해서 사용하면 에러의 발생을 줄일 수 있다
증가 반복에서는 < or <=연산을 사용하고  감소 반복에서는 > or >=연산을 사용한다
> < >= <=대신 ==연산을 사용하려면 초기 설정이 필요하다 

for문에서 표현식 생략
for문은 생각보다 유연한 구문이다 for문에서 3개의 표현식을 모두 넣을 필요는 없다 첫 표현식을 제외할 떄느느 
초기값을 반복 전에 설정하면 된다
ex) i = 10;   for( ; i >0; --i){  }
세번째 표현식을 생략할 때는 반복 내용에 두번째 표현식이 0이 나오게 할 수 있는 연산이 필요하다
ex) for(i = 10; i > 0; ){  printf("%d", i--);}
두번쨰 표현식이 생략되면 반복이 종료되지 않아서 무한루프가 된다

C99에서의 for문
C99에서 첫 표현식을 변수의 선언으로 대체할 수 있다 
ex) for(int i = 0; i < n; i++)
이미 변수가 선언되어있으면 해당 변수는 반복문 안에서만 사용되는 변수가 된다 이렇게 생성된 변수는
반복문 밖에서는 접근할 수 없다 이렇게 반복문 내에서 변수를 선언하면 이해하기가 쉽다 하나 이상의 변수도 선언이 가능하다
ex) for(int i = 0, j = 0; i <n; i++){

쉼표 연산자 (comma operator)
첫번쨰 표현식, 세 번쨰 표현식에서 다양한 변수를 조정할 때 쉼표 연산자를 사용한다 쉼표연산자의 형태는 다음과 같다
ex)  expr1 , expr2
expr1과 expr2는 어느 표현식이든 가능하다 expr1이 먼저 계산되고 그 값은 버려진다 
그 다음에 expr2가 계산되고 그값이 전체 표현식의 값이 된다 그렇게 때문에 expr1에는 부과효과를 줘야한다
ex) i = 1 j = 5 ;   ++i, i + j 가 있을 때  i가 ++돼서 2가 되고 5를 더해서 해당 표현식은 7이 된다
쉼표 연산자의 우선순위는 다른 연산자들보다 낮다 
쉼표 연산자는 C에서는 한개의 표현식을 원하지만 두개나 그 이상의 표현식을 사용하고 싶을 때 쉼표 연산자를 사용하면된다
ex)for(sum = 0, i = 1; i <= N; i++){

반복문 종료 (Exiting from a Loop)
반복문을 빠져나올때는 반목 내용문을 실행하기 전에 표현식을 통해 하거나 반복내용 실행 후 표현식을 통해 하였다
break문을 사용하면 중간에 반복을 빠져나올 수 있다 continue와 got문도 있는데 continue는 반복은 종료되지 않고
현재 실행중인 반복 내용을 스킵한다 goto는 다른 문으로 이동을 시켜준다 goto는 거의 사용하지 않는다 

break문
switch에서도 break문을 사용하였었는데 switch에서와 마찬가지로 break문은 for , while , do문 밖으로 이동시켜준다
break는 반복내용 시작과 끝쪽보다는 중앙쪽에 놓는것이 좋다 , for ,while, do, switch문이 중첩되어 있다면
break는 한 개의 구문만 빠져나올 수 있게 한다 
ex) while() {  switch() { ... break}}  switch문은 빠져나오지만 while문은 빠져나오지 못한다 

continue문
continue문은 반복을 빠져나오는 것은 아니다 break문과 유사하지만 break문은 반복을 완전히 빠져나오지만 continue는
반복문을 빠져나가지 못하고 반복의 처음으로 되돌아간다 그리고 break문은 switch문에서도 사용이 가능하지만 continue문은 반복에서만 사용이 가능하다 


goto문
break와 continue문은 다른 지점의 문으로 점프를 시켜주는데 두 문은 제한적이다 break는 반복문 끝을 넘어선 지점이고
continue는 반복의 끝 전 지점이다 반면에 goto문은 함수 라벨로  어느 문으로든지 이동이 가능하다  (C99에서는 
가변길이의 배열 선언을 우회할 수 없다는 제약이 있다)
label의 선언은 다음과 같이 한다
identifier : statement
한개 이상의 라벨이 있을 떄 goto문은 다음과 같이 사용한다
goto identifier;
goto문을 실행하면 identifier을 선언한 곳으로 문을 이동한다 
 break, continue , return등은 근본적으로 제한이 있기 때문에 goto문은 가끔 필요하다 

NUll문
Null문은 세미콜론을제외하고는 아무것도 없는 문이다 예는 다음과 같다
ex) i = 0;  ;  j = 1;
Null문은 내용이 비어있는 반복문을 사용할 떄 주로 사용된다 
null문은 간결하지만 일반적으로 효율적이지는 않다 
if, while, for문 뒤에 세미콜론을 놓으면 Null문이 만들어진다  
if문 뒤에 세미콜론을 넣으면 조건식에 관련없이 같은 동작을 하게된다 

while문 안에 continue가 있는 경우 for문으로 변환을 할 수가 없다 
무한루프를 만들 때 프로그래머들은 오래된 컴파일러에서 더 호율적이여서 for(;;)를 사용했다
while루프는 반복을 돌떄마다 1 조건식을 체크하기 때문이다 현대 컴파일러는 차이가 없다 
goto문은 나쁘지는 않지만 보통 goto문보다 더 나은 대안이 있다  그리고 goto문을 사용하면
스파게티 코드가 되기 쉬운데 스파게티 코드는 읽고 이해하기가 어렵다 goto문을 쓰면 앞뒤로 점프해서 읽기가 어려워진다 
null문은 어디든지 사용할 수 있지만 실직적으로 사용은 루프의 몸체가 비었다는 것을 나타내는 한가지 용도로만 한다 

chap7  Basoc Types

integer 타입
C는 근본적으로 두 종류의 숫자 타입을 제공한다 integer와 floating타입인데 integer타입은 모든 숫자이고 
floating type은 분수를 가질 수 있다 integer은 signed와 unsinged로 나뉜다 
가장 왼쪽의 비트는 sign bit이고 이 비트가 0이면 0이거나 양수이고 1이면 음수이다 
그래서 16bit의 수일떄 가장 큰 수는  011111111111111 이 되고 값은 32767(2의 15승 -1) 이 된다 
32bit일 때는 01111111111111111111111111111111이 되고 값은 2147483647(2의 31승 -1)이 된다 
unsinged는 sgin bit를 사용하지 않기 때문에 16bit일 떄 가장 큰 수는 65535(2의 16승 -1)이 되고
32bit일때 가장 큰 수는 4294967295(2의 32승 -1)이된다 
기본으로 singend가 붙기 때문에 unsinged를 사용하기 위해서는 unsinged를 선언해줘야 한다 
unsigned는 시스템 프로그래밍과 기계 어플리케이션에 의존하는 낮은 레벨에서 유용하다 
C언어에서 integer자료형은 다른 크기를 가진다 int타입은 보통 32비트이지만 오래된 CPU에서는 16bit이다
그리고 int보다 큰 수를 넣기 위해 C는 long자료형을 제공하고 메모리를 보존하기 위해 더 작은 공간인 short자료형을 제공한다
다음 6개 조합은 다른 자료형을 만든다
short int   /  unsigned short int   
int / unsigned int
long int / unsinged log int
다르게 조합해도 6개중에 하나의 타입이 된다 
ex) long signed int 는 long int와 동일하다 그리고 순서도 상관없어서 unsigned short int 와 short unsigned int는 동일하다
C는 int를 뺴서 축약하는 것을 허용한다  축약해서 사용하는 것이 더 흔하다
ex) unsigned short int = unsigend short   , log int = long 
6개의 타입의 범위는 기계마다 다르다 하지만 모든 컴파일러는 short , int ,long은 최소 범위 값을 가져야 하고
int는 short보다 짧아서 안되고 long은 int보다 짧으면 안된다 하지만 같은 범위는 가질 수 있다 

16bit기계에서 6자료형의 범위는 다음과 같다
Type 			최소 범위		최대 범위
short int 			-32,768		32,767
unsinged sohrt int 	0		65,535
int			-32,768		32,767
unsinged int 		0		65.535
long int 			-2,147,483,648	2,147,483,647
unsined long int 		0		4,294,967,295

32bit기계에서 6자료형의 범위는 다음과 같다
Type 			최소 범위		최대 범위
short int 			-32,768		32,767
unsinged sohrt int 	0		65,535
int			-2,147,483,648	2,147,483,647
unsinged int 		0		4,294,967,295
long int 			-2,147,483,648	2,147,483,647
unsined long int 		0		4,294,967,295

최근에 64bit CPU는 더 흔해졌다 64비트 기계에서 범위는 다음과 같다
Type 			최소 범위		최대 범위
short int 			-32,768		32,767
unsinged sohrt int 	0		65,535
int			-2,147,483,648	2,147,483,647
unsinged int 		0		4,294,967,295
long int 			-9,223,372,036,854,775,808	9,223,372,036,854,775,807
unsined long int 		0		18,446,744,073,709,551,615
해당 범위가 필수적인 것은 아니고 컴파일러마다 다양하다 자료형의 범위를 결정하는 하나의 방법은 
<limit.h>헤더에서 정의한것을 따르는 것이다 해당 헤더는 최소값, 최대값 매크로를 정의한다

C99에서 정수형 타입
C99에서는 두개의 추가 정수형 자료형을 지원한다 
long long int와 unsinged long long int이다 
매우 큰 정수형이 필요해지고 64비트 산술 프로세서가 생기면서 해당 자료형이 추가되었다 
long long자료형은 최소 64비트여야 한다 보통 크기는 -2의 63승에서 2의 63승 -1이다
unsigned long long int의 범위는 보통 0에서 2의 64승 -1이된다
short, int, long,long long은 C99에서 기본 signed 정수 자료형이라고 부른다
unsigned short , unsigned int, unsigned long , unsigned long long은 기본 unsigend 정수 자료형으로 불린다 
또한 C99는 signed와 unsigend에 대해 확장된 정수 자료형을 지원한다 컴파일러는 128bit의 자료형도 지원이 가능하다 

정수형 상수(integer constant)
C는 정수형 상수로 10진수 ,8진수,16진수를 허용한다 

10진수 상수는 0~9의 숫자로 이루어지고 0으로 시작해서는 안된다 
ex) 15 255 32767
8진수 상수는 0~7의 숫자로 이루어지고 0으로 시작한다
ex) 017 0377 07777
166진수 상수는 0~9의 숫자, a부터 f까지의 문자로 이루어지고 0x로 시작한다
ex) 0xf 0xff 0x7fff
해당 진수는 숫자를 쓰는 방식일 뿐 실제로 저장되는 것과는 관련이 없다 정수는 항상 2진수로 들어간다 
진수는 섞어서도 사용이 가능하다
ex) 10 + 015 + 0x20   
8진수와 16진수는 낮은 레벨 프로그램에 편리하다 
10진수 상수의 타입은 보통 int이지만 숫자가 너무 크면 long int이다 더 숫자가 크면 unsinged long int까지된다
8진수와 16진수는 조금 다르다 적절한 자료형을 찾을 떄까지 int, unsigend int , long int , unsined long int를 
확인한다 컴파일러가 상수를 long으로 보게 하려면 끝에 L을 붙이면 된다
ex) 15L  0377L  0x7ffffL
상수가 unsigned를 나타내기 위해서는 U를 끝에 붙인다
ex) 15U 0377U 0x7ffffU
long과 unsigend를 동시에 나타내려면 U와 L을 같이 붙인다
ex) 0xffffffUL

C99에서 정수형 상수 
C99에서는 LL을 붙여서 long long 자료형이 되게 할 수 있다 U를LL 앞에 붙이면 unsigend long long int를 만들 수 있다
C99에서 자료형을 결정하는 방식은 조금 다르다 10진수 값을 나타낼 수 있는 자료형 중 가장 작은 자료형이 타입이 된다
8진수와 16진수는 int , unsigned int , long int , unsigned long int, long long int , unsigned long long int순서대로
가능한 자료형이 들어간다 
상수의 끝에 U가 붙으면 unsinged자료형 중에 하나가 된다 L이 붙으면 long이상의 자료형이 된다 

정수 오버플로우(integer overflow)
정수의 연산이 수행됐을 때 나타낼 수 있는 범위보다 큰 숫자가 나오는 경우가 있다 
int자료형끼리 연산을 하면 결과도 int로 나타나야 한다 나타낼 수 없다면 오버플로우가 발생한다 
오버플로우가 발생했을 때 피연산자가 singed인지 unsigned인지에 따라 달라진다 
sigend연산에서 오버플로우가 발생하면 프로그램은 undefined가 된다 undefined행동은 다양하다 
계산이 잘못되었거나 프로그램이 파괴되어 의도하지 않은 행동을 해도 발생한다
unsigned 정수형에서 오버플로우가 발생하면 결과는 defined가 된다 2제곱의 수를 얻는데  
제곱 수는 결과를 저장하는데 사용된 비트의 숫자이다 예를 들어 65535에 1을 더하면 0이된다 

정수 읽고 쓰기
오버플로우가 발생해서 프로그램이 동작하지 않으면 먼저 int를 long int로 바꿔야 한다 또한 바꿨을 때 
영향을 주는 것들도 바꿔야 한다 특히 printf와 scanf를 확인해야 한다 %d는 int타입에서만 동작하기 떄문에 바꿔야 한다
unsigned int를 읽을 때 d대신 u, o , x를 사용해야 한다
u는 10진수로 수를 읽고 o는 8진수로 수를 읽고 x는 16진수로 읽는다  
ex) unsigned int u;  scanf("%u", &u);  (10진수로 읽음) printf("%u", u); (10진수로 출력
scanf("%o", &u); (8진수로 읽음 )   printf("%o", u); (8진수로 출력)   scanf("%x", &u) (16진수로 읽음) printf("%x",u); (16진수로 출력)
short자료형을 읽을 때 h를 d,o,u,x앞에 붙여야 한다
ex) short s; scanf("%hd", &s);  printf("%hd", s);
long을 읽을 때 l을 d,o,u,x앞에 붙여야 한다 
ex) long s; scanf("%ld", &s);  printf("%ld", s);

실수형 타입(floating type)
정수형 자료형이 모든 어플에 맞지는 않다 때때로 소수점을 사용하거나 아주 크거나 아주 작은 변수를 사용해야 한다 
이런 숫자들은 부동 소수점 형식으로 저장된다 C는 3가지의 실수형 타입을 제공한다 
float   -  단일 정밀도 부동소수점
double -  배정밀도 부동소수점
long double -확장 정밀도 부동소수점
float는 정밀도가 중요하지 않을 떄 사용한다 double은 대부분 프로그램에 충분한 좋은 정밀도를 제공한다 
확장 정밀도는 엉청난 정밀도를 제공하지만 거의사용하지 않는다 
이것들이 얼마나 정확한지 C표준은 제공하지 않는데 컴퓨터들이 다른 방식으로 부동소수점을 저장하기 떄문이다 
대부분 현대 컴퓨터는 IEEE standard 754를 사용하고 있다 
IEEE 표준에 따른 실수형 타입의 범위는 다음과 같다
타입		최소 범위				최대 범위				정밀도
float		1.17549*10의 마이너스 38제곱        3.40282 * 10의 38제곱		6자리
double		2.22507*10이ㅡ 마이너스 308제곱	1.79769 * 10의 308제곱		15자리
long double은 나타나지 않는데 기계마다 다르기 떄문이다
IEEE표준을 따르지 않는 컴퓨터에게는 위 표는 유효하지 않다 일부 컴퓨터에서는 float 와 double이 같고
double이 long double이 같다 <float.h>헤더에서 실수형 자료형의 특징 매크로를 찾을 수 있다
C99에서 실수형은 두 카테고리로 나뉘는데  float, double , long double이 하나로 묶이고 real floating이라고 불린다
하나는 complex type이다 float_Complex double_Complex long double_Complex가 C99에서 추가되었다 

실수형 상수(Floating Constant)
실수형 상수는 다양한 방법으로 쓰인다 다음은 57을 다양한 방법으로 쓴 예이다
ex) 57.0 57. 57.0e0  57E0   5.7e1   5.7+e1  .57e2   570.e-1
실수형 상수는 반드시 소수점이나 지수를 포함해야 한다 지수는 10제곱형태로 나타난다
지수가 있으면 반드시 E를 쓰고 +나 -는 e다음에 써야한다 
실수형 상수는 기본으로 double로 저장된다 필요하면 float로 변환하기 때문에 문제가 생기지 않는다 
강제로 float나 long double형태로 만들 필요가 있을 수 있는데 
float형태로 바꾸려면 끝에F를 , long double형태로 바꾸려면 끝에 l을 붙이면 된다 
ex) 57.0F     57.0L
C99에서는 실수형 상수를 16진수로 쓰는 것을 제공하는데 0X로 시작을 하면된다 거의 사용되지는 않는다 

실수형 숫자 읽고 쓰기 
%e  %f   %g는 float를 읽고 쓰는데에 사용된다 double형과 long double형은 조금 다르다 
double을 읽을 떄는 l을 e,f,g,앞에 놓는다
ex) double d; scanf("%lf", &d);  l은 오직 scanf에서만 사용하고 printf에서는 사용하지 않는다 
%e ,   %f  , %g는	float와 double에 둘다 사용이 가능하다 C99에서는 %le %lf %lg를 사용가능하게 했지만 효과는 없다
long double을 읽을 떄는 L을 e, f, g, 앞에 붙인다
ex) long double ld;  scanf("%LF", &ld); printf("%LF", ld);

문자 타입( Character Types)
문자 타입은 char만 존재한다 char는 컴퓨터마다 다양하게 나타날 수 있다 기계마다 문자셋이 다르기 때문이다
현제 가장 유명한 문자셋은 아스키이다(american standard code for information interchange)
128문자를 나타낼 수 있는 7bit코드이다 아스키 코드는 더 많은 문자를 표현하기 위해 종종 확장된다
char자료형은 단일 문자를 할당받는다
ex) char ch;  ch = 'A'; ch = 'A' ch = '0'  ch = ' ';
char는 큰따옴표가 아니라 작은따옴표로 묶인다

문자 연산(Operations on Characters)
C에서 문자가 동작하는것은 간단한데 C에서는 문자를 작은 정수로 다룬다 문자는 2진수로 인코딩된다
아스키코드에서 문자 코드의 범위는 0000000부터 111111이다 이것을 숫자로 생각하면 0부터 127이된다
a는 97 A는 65 0은 48로 매칭이 된다 문자와 숫자의 연관성이 아주 강해서 문자는 char보다 int를 가진다
문자가 연산할 떄 C언어는 단순히 그것을 정수로 사용한다 
ex) char ch; int i;  i = 'a';(i = 97)  ch = 65(ch = A);  ch= ch + 1(ch = B); ch++;(ch = C)
문자는 숫자처럼 비교도 가능하다 
ex) if('a' <=ch && ch <= 'z') ch = ch - 'a' + 'A';
이러한 값들은 문자셋에 의존한다 그래서 문자 비교는 휴대성이 좋지는 않다 문자를 숫자로 처리하는것은
여러 이점이 있다 반면에 문자를 숫자로 처리하는것은 컴파일러가 잡지 못하는 다양한 에러가 
발생할 수 있다 또한 문자셋에 의존하기 때문에  휴대성을 방해할 수 있다 

signed, unsigned 문자
C에서는 문자를 정수로 사용하기 떄문에 char도 int처럼 singed와 unsigend가 존재한다 
signed char는 -128부터 127이고  unsigend char는 0부터 255의 값을 가진다
C표준에서는 평범한 char가 signed인지 unsigned인지 명시하지 않는다 
몇몇 컴파일러는 signed가 기본이고 다른 몇몇은 unsigned가 기본이다 
하지만 대부분의 경우 signed인지 unsigned인지 신경쓸 필요가 없다 
만약 char를 작은 정수로 사용하고 있다면 신경써야 하기때문에 C에서는 char에 signed와 unsigned를 허용한다
이것을 신경쓰는 사람은 char앞에 signed와 unsgined를 붙이면 된다 
C89에서는 char를 정수 자료형이라고 한다 열거형 자료형 또한 정수형 자료형이다
C99에서는 정수형 자료형이라고 하지는 않지만 문자와 열거형 , _Bool자료형도 정수 자료형이라고 한다

산술 타입(Arithmetic Types)
정수형과 실수형은 통합적으로 산술 타입으로 알려져 있다 
C89에서 나눈 산술 타입의 카테고리는 다음과 같다
Integer type
 - char
 -signed integer types(signed char short int , int , long int)
 - unsigned integr types(unsigned char , unsigned short int , unsigned int , unsigned long int)
 - Enumerated types 
Floating types (float, double, long double)
C99는 산술타입을 더 복잡하게 나눈다
Integer type
 - char
 -signed integer types , both stanard(signed char short int , int , long int , long long int) , and extended
 - unsigned integr types , both standard(unsigned char , unsigned short int , unsigned int , unsigned long int, unsigned long long int , _Bool) , and extended
 - Enumerated types 
Floating types 
 - real floating types((float, double, long double)
 - complex types( float_Complex, double_Complex , long double_Complex)

확장 비트열(escape sequences)
문자 상수는 보통 작은 따옴표로 묶인 하나의 문자이다 하지만 새로운 라인 등 이런 방식으로 쓰이지 않는 특별한
문자가 있다 이것들은 키보드로 입력받을 수 없고 보이지 않는다 프로그램이 모든 문자를 다룰 수 있게 C는
확장열을 제공한다 확장열은 character escpaes와 numeric escape가 있다 
이름		확장열
Alert(bell) 	\a
Backspace	\b
Form feed	\f
new line		\n
Carriage return 	\r
Horizontal tab	\t
Vertical tab	\v
Backslash		\\
Question mark	\?
sing quote	\'
double quote	\"
\a, \b, \f, \r, \t, \v는 일반적인 아스키 제어 문자이다 \n은 아스키 line-feed문자이다 \\는 
\문자를 포함할 수 있도록 해준다 \' \"도 '와 "문자를 포함할 수 있게 한다 
Character escape는 편리하지만 문제가 있다 출력되지 않는 아스키 문자는 포함하지 않는다 
128개의 아스키 문자 이외에는 의미가 없다 
numeric escape는 어느 문자도 표현이 가능해서 이 문제를 해결할 수 있다 
이것을 사용하기 위해서는 테이블에서 문자의 8진 또는 16진수의 값을 찾아야 한다 
이 코드들은 escape sequence로 사용될 수 있다
- 8진escape sequence는 \와 최대 3자리의 8진수로 구성된다 반드시 unsigned를 나타낼 수 있어야 한다
그래서 최대값은 보통 8진수 377이다  \33 또는 \033와 같이 쓰이는데 0을 처음에 쓸 필요는 없다
-16진 escape sequence는 \x와 16진수로 이루어진다 unsinged를 나타낼 수 있어야 한다 
사용은 \x1b 또는 \x1B와 같이 하는데 x는 반드시 소문자로 사용해야 하지만 16진수부분의 문자는
대소문자를 모두 사용할 수 있다 
문자 상수로 escape sequence가 사용되면 작은따옴표로 묶여야 한다 
escape sequence를 #define으로 사용하는 것은 좋다
ex) #define ESC '\33'
C99에서는 escape sequence와 비슷한 universal character names를 추가하였다 
여기서는 식별자가 허용된다 

문자 처리 함수(Character-Handling Function)
소문자를 대문자로 변환하는 빠르고 좋은 방법은 라이브러리에서 제공하는 toupper함수를 사용하는 것이다
ex) ch = toupper(ch);
매개변수가 소문자이면 대응하는 대문자를 반환한다  사용하기 위해서는 <ctype.h>헤더가 필요하다

문자를 scanf와 printf에서 읽고 쓰기
%c를 사용하면 printf와 scanf에서 문자를 읽고 쓸 수 있다 
ex) char ch ; scanf("%c", &ch);   printf("%c" , ch);
scanf는 문자를 읽기 전까지 공백을 스킵하지 않는다 다음 읽지 않은 문자가 공백이면 공백을 리턴한다
공백을 스킵하게 하려면 서식 문자열에 %c전에 공백을 줘야한다
ex)scanf(" %c", &ch);

getchar와 putchar를 이용한 문자 읽고 쓰기
C는 하나의 문자를 읽고 쓰는 방법을 지원한다 getchar와 putchar함수를 사용하면된다
putchar는 하나의 문자를 출력한다
ex) putchar(ch)
getchar를 호출하면 하나의 문자를 읽어서 리턴한다 
ex) ch = getchar() 
getchar는 실제로는 문자 값이 아닌 int값을 리턴한다 scanf처럼 getchar도 공백을 스킵하지 않아서 공백을 읽는다
getchar와 putchar를 사용하면 프로그램 실행 시간을 줄일 수있는데 printf와 scanf보다 간단하고 속도를 위한
매크로가 있다 getchar는 읽은 문자를 반환하고 다양한 문에 getchar를 사용할 수 있다 
ex) while(getchar() != '\n');
getchar와 scanf를 동시에 사용할 때 주의해야 할 점이 있는데 scanf가 발견했지만 읽지 않은 남은 문자들이 있을 수 있다
개행문자를포함해서 
ex) scanf("%d", &i); a = getchar(); 이떄 정수를 입력하고 엔터를 누르면 개행문자가 생긴다 그리고 scanf는 문자만 읽어서
개행문자가 남게된다 그리고 getchar를 호출하면 남아있던 개행문자를 a에 저장하게된다 12345d를 입력해도
d가 남아 d가 저장된다 

타입 전환(Type Conversion)
컴퓨터는 C언어보다 산술 연산에 더 제한적이다 컴퓨터는 피연산자의 형식이 같아야하지만 
C언어는 다른 타입의 숫자를 섞어서 사용하는 것을 허용한다 16bit인 short와 32bit인 int를 계산하면 short를
32bit로 변환해서 계산한다 그리고 int와 float를 계산하면 int가 float로 변환된다 자동으로 변환되는 것이기 떄문에 
암시적 전환이라고 불린다 C는 또한 프로그래머가 cast연산을사용해서 명시적으로 변환하는것을 허용한다 
암시적 변환은 다음 상황에서 수행된다 
- 연산에서 피연산자가 동일한 타입이 아닐 떄 
- 오른쪽 타입이 왼쪽 변수와 다를 때 
- 함수 호출할 때 파라미터의 자료형이 같지 않을 때 
- return타입과 return하는 값의 타입이 같지 않을 때 

일반 산술 변환(The Usual Arithmetic Conversions)
일반 산술 연산은 산술, 관계, 동등 연산의 피연산자에 적용된다 
ex) i + f 의 연산이 있을 떄(i = int f = float) i는 float형으로 변환되고 일반 산술 변환이 일어난다 
int는 항상 float로 변환이 가능하다 그리고 정밀도를 거의 잃지 않는다
반면에float에서 int로 변환하면 소수점 부분을 잃게된다
일반 산술 변환의 전략은 피연산자들을 안전하게 수용할 수 있는 것으로 변환하는 것이다
피연산자는 더 작은 자료형을 다른 자료형으로 변환한다 이것을 promotion으로 부른다
가장 일반적은 promotion은 integral promotion인데 문자나 short을 int로 바꾸는 것이다 
일반 산술 변환은 두 케이스로 나눌 수 있다 
- 모든 자료형이 실수형 타입일 때 : 좁은 자료형이 밑의 순서에 따라 이동한다 
 float -> double -> long double
하나의 피연산자가 long double이면 다른 피연산자도 long double이 된다 정수형 실수형이
섞여있을 떄도 마찬가지인데 double과 long int가 섞여있으면 long int가 double로 변환된다
-실수형 자료형이 없는 경우 : integral promotion이 각각 피연산자에 수행된다 (char나 short이 아니게 하기 위해)
그리고 나서 좁은 자료형이 밑의 순서에 따라 이동한다
int -> unsigned int -> long int-> unsigned long int 
특별한 케이스가 있는데 long int와 unsigend int의 크기가 같을 때 둘다 unsigned long int로 변환된다
signed와 unsigned를 같이 연산하면 singed는 unsigend로 변환된다 
그런데 int 가 -10일때 unsinged로 변환되면 이상한 값이 된다 그래서 unsinged는  signed와 같이 안쓰는게 좋다 

할당 중 전환(Conversion During assginment)
일반 산술 변환은 할당할 떄는 적용되지 않는다 대신 C는 오른쪽 표현식이 왼쪽 변수 타입으로 변환되어야 한다
변수의 타입이 표현식보다 넓으면 문제없이 동작한다 하지만 실수를 int에 넣을떄는 소수점 부분이 사라진다 
ex) int i; i = 842.97;   (i = 842)
또한 변수의 범위가 아닌 값을 넣으면 의미없는 결과나 잘못될 결과를 야기한다
ex) char c = 10000;   int i = 1.0e20;
이러한 할당은 lint에서 경고를 출력한다 

C99에서 암시적 변환
C99에서 암시적 변환은 조금 다르다 C99에는 _Bool long long int등의 자료형이 추가되었기 때문이다 
C99에서는 정수형 타입 순위를 두었는데 순위는 다음과 같다
1. long long int , unsined long long int
2. long int . unsigned long int
3. int , unsinged int
4. short int  , unsinged short int
5. char , signed char, unsigend char
6. _Bool
확장된 정수형과 열거형은 여기에 없다 C89의 integral promotion이 C99에서는  integer promotion을 가진다
int보다 낮은 랭크는 int나 unsigned int로 변하는 것이다 
C89 , C99에서 일반 산술 전환 규칙은 두 케이스로 나뉜다 
- 모두 실수형일 때 : complex자료형이 아니면 이전과 같다 
- 실수형이 없을 때 : integer promotion이 두 피연산자에 수행되고 같아지면 끝이고 다르면 다음 규칙중 하나가 적용된다
  * 둘다 signed나 unsigned면 작은 쪽이 큰 쪽으로 변환된다
  * unsigned 피연산자가 더 랭크가 높으면 unsinged로 변환된다 
  * signed 피연산자의 자료형이 모든 unsinged값을 나타낼 수 있으면 singed자료형으로 변환된다
  * 그렇지 않으면 unsigned로 변환된다 
_BOOL타입으로 변환된다면 0이면 0이고 아니면 1이된다 

Casting
비록 C에서 암시적 변환이 있지만 때때로 타입을 컨트롤 할 필요가 있다
그래서 C는 cast를 제공한다 표현식은 다음과 같다
ex) (type-name) expression   여기서 type-name은 변환될 자료형을 나타낸다 
ex) float f , fract_prat;  fract_part = f - (int)f;   실수형의 정수부분을 빼서 소수점 부분을 가지게 된다 
casting은 어디서든 가능하고 컴파일러를 넘어서 원하는 자료형으로 변환해준다 
ex) quotient = (float)dividend/ visisor;  여기서 visior는 캐스트가 필요 없는데 dividend를 변환하면서 visior은 
컴파일러가 자동으로 float로 변환하기 때문이다 그리고 캐스트는 단항 연산자여서 이항 연산자보다 우선쉰위가 빠르다
ex) (float) dividend / divisor   =  ((float) dividend) / divisor
캐스트는 오버플로우를 피하기 위해서 필수적일 떄도 있다 
ex)llong i; int j = 1000;  i = j * j;   보기에는 문제 없어보이지만 일부 기계에서는 오버플로우를 발생시킨다
i = (long) j * j 이렇게 캐스팅을 하면 오버플로우가 발생하지 않는다 하지만 다음과 같이는 하면 안된다
ex) i = (long) (j *j)  이렇게하면 이미 오버플로우가 발생해서 적용이 안된다 

자료형 정의 (Type Definitions)
자료형 정의를 사용하면 자료형을 더 잘 정의할 수 있다
ex) typedef int Bool;
자료형 이름은 마지막에 들어간다 이름의 대문자는 관습일 뿐 지킬 필요는 없다 
typedef를 사용하여 자료형을 정의하면 컴파일러의 타입 리스트에 추가가 된다 
내장된 자료형처럼 선언, 캐스트 등을 어디서든 사용할 수 있게ㅔ된다 

자료형 정의의 장점 (Advantages of Type Definitions)
자료형 정의는 프로그램을 더 이해하기 쉽게 만들어준다 또한 수정도 쉽게 만들어준다 바꿀 떄 
일반적인 자료형이 아닌 선언한 자료형쪽만 바꾸면 되기 떄문이다 

자료형 정의와 이식성(Type Definitions and Portabillity)
자료형 정의는 이식성이 좋은 프로그램을 만드는 데에 중요한 도구이다 프로그램을 다른 컴퓨터로 옮겼을 때 
타입의 범위가 달라질 수 있다 이때 자료형 정의 부분의 자료형만 바꿔주면 바로 해결이 된다 
하지만 이기술은 모든 문제를 해결해주지는 않는다 printf나 scanf에서 해당 자료형을 사용할 때 쓴 %d등도 바꿔줘야 하기 때문이다
C99에서 <stdint.h>헤더는 typedef를 사용하여 특정 숫자의 bit정수를 정의했다 
ex) int32_t   32bit정수 자료형인데 이런 자료형은 이식성을 좋게 만든다 

sizeof 연산(The sizeof Operator)
sizeof연산은  특정 타입의 변수를 저장하는데 얼마나 많은 메모리를 사용하는지 알려준다
ex) sizeof( type-name)
sizeof(char)는 항상 1이된다 그러나 다른 타입은 다양하게 출력될 수 있다 32비트 기계에서 
sizeof(int)는 보통 4이다 컴파일러가 스스로 sizeof값을 결정한다 
sizeof연산자는 상수, 변수, 표현식에도 적용이 가능하다 
ex) int i; sizeof(i) 의 값은 32비트 기계에서 4가 된다 
표현식에서 사용할 때 괄호는 필요없지만 우선순위 때문에 쓰는것이 좋다 
sizeof는 단항 연산자여서 이항 연산자들보다 순위가 높다 
sizeof의 값을 출력할 떄 주의해야할것이 있는데 sizeof 표현식의 자료형은 size_t이다 
C89에서는 이떄문에 출력할떄 캐스팅을 사용하였다
ex) printf("%lu\n", (unsinged long) sizeof(int));
C99에서 size_t는 unsigned long보다 클 수 있다 그러나 printf함수에서 size_t자료형을 캐스트없이 직접적으로 
표시하는것이 가능해졌다 
ex) printf("%u", sizeof(int));

음수를 8진,16진수로 표현하는 직접적인 방법은 없다 이렇게 표현하는 경우도 거의 없다 간접적인 방법으로 다음과 같이 한다
ex) if(i < 0) printf("-%x", -i);
C는 double을 float보다 선호하기 때문에 실수가 double로 저장이 된다
16진 실수 상수는 정밀도가 높은 수를 표현하는데에 유용하다 16진수는 2진수를 명확하게 나타내지만
10진수는 2진으로 변환할 떄 에러가 있을 수 있다
printf에서 float는 자동으로 double로 변환하기 때문에 컴파일러는 이를 구분하지 못한다 그래서 printf에서 double을
출력할 떄 %f를 사용한다 하지만 scanf는 변수를 포인터에 넘겨서 %f는 float값이 저장되고 %lf는 double값이 저장된다
만약 잘못된 변환지시자를 주면 scanf는 잘못된 byte숫자를 저장할 수 있다
문자를 저장할 떄 7비트만 사용하면 singnd와 unsigned과 상관없는데 8bit문자를 저장한다면 
unsigned char에 저장해야한다 문자로만 쓰면 상관이 없지만 숫자로 사용한다면 char가 기본으로 signed로된다면
음수가 된다 
??가 문자열에 있으면 컴파일러가 trigraph의 시작으로 착각할 수도 있어서 \?을 사용한다 
자료형 정의와 매크로 정의는 큰 차이점이 있다 먼저 자료형 정의는 매크로정의보다 훨신 강력하다 
특히 배열이나 포인터는 매크로로 정의되지 않는다 
ex) #define PTR_TO_INT int*   PTR_TO_INT p, q,r 이렇게 했을 때 p만 포인터가 되고 q,r은 일반 변수가 된다 
또한 typedef의 이름은 scope규칙에 영향을 받는다 함수 내부에서 정의된 typedef는 다른 함수에서는 사용할 수 없지만
macro의 이름은 어디에 있던지 적용된다 

chap8 Arrays
C는 종합 변수도 제공하는데 이는 값의 집합을 저장할 수 있다 두 종류의 종합 변수가 있는데  배열과 구조체이다

1차원 배열 ( One-Dimensional Arrays)
배열은 많은 값을 포함하고 있는 데이터 구조이다 모든 값은 같은 자료형을 가진다 요소로 알려진 값들은
각각 선택되고 위치를 가진다
가장 간단한 종류의 배열은 1차원 배열이다 이는 요소가 한 행으로 구성된다 
일차원 배열은 다음과 같이 생겼다
a  ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ
배열을 선언하기 위해 배열의 숫자와 자료형을 명시해야 한다 
ex) int a[10];
배열의 자료형은 어느것이든지 올 수 있고 배열의 길이는 어느 정수인 상수가 올 수 있다 
배열의 길이는 나중에 바뀔 수 있기 떄문에 매크로를 사용하는것은 좋은 습관이다

Array Subscriotion
배열의 특정 요소에 접근하기 위해 대괄호에 정수를 넣어서 사용한다  subscription또는 인덱싱 한다고 한다 
배열의 요소는 0부터 번호가 매겨지고 크기가 n이라면 0부터 n-1까지 번호가 매겨진다 
ex) ㅁ    ㅁ   ㅁ  ㅁ   ㅁ   ㅁ    ㅁ   ㅁ   ㅁ   ㅁ     a[10]
    a[0] a[1] a[2]  a[3] a[4] a[5]  a[6] a[7] a[8] a[9] 
a[i] 표현식은 lavalue여서 평범한 변수와 같은 방식으로 사용된다 
배열이 자료형 T의 요소를 포함하고 있으면 배열은 자료형 T의 변수처럼 사용된다
배열과 반복문은 연관이 깊다 많은 프로그램은 배열의 요소를 동작시키는 for문을 포함하고 있다
ex) for (i = 0; i <N; i++) a[i] =0;     for(i = 0; i < N ; i++ ) scanf("%d", &a[i];  
일반 변수처럼 scanf를 호출할 떄 &를 배열에도 붙여야 한다 
배열의 범위가 넘어가면 프로그램은 undefined를 행동한다 이 실수는 배열이 0부터 n-1까지라는 것을 잊을 때 야기된다
ex) int i[10] for(i = 1; i <= 10; i++) a[i] =0
배열의 번호는 어떤 표현식도 올 수 있다 또한 sideEffect를 가질 수 있다
ex) a[i+j*10] = 0;     a[i++] = 0;
side Effect를 가질 떄 주의할 점이 있다 다음과 같이 사용하면 원하는 결과가 나오지 않는다
ex) while(i <N) a[i] = b[i++]; 이것을 다음과 같이 변경해야 한다 for(i = 0; i <N; i++) a[i] = b[i]

배열 초기화 (Array Initialization)
다른 변수처럼 배열도 값을 초기화할 수 있다
가장 흔한 형태는 중괄호로 묶고 콤마로 분리한다 
ex) int a[10] = {1,2,3,4,5,6,7,8,9,10};
중괄호의 요소의 수가 적으면 할당이 되지 않은 요소는 0으로 초기화된다 
ex) int a[10] = {1,2,3,4,5,6}     =>  1,2,3,4,5,6,0,0,0,0
이걸 이용하면 쉽게 0으로 초기화가 가능하다 
ex) int a[10] = {0};
초기값을 완전 빈것을 넣을 수 없기 때문에 중괄호 안에 0은 넣어야 한다 배열보다 많은 수를 넣는거도 안된다
초기값이 있다면 배열의 길이는 생략할 수 있다
ex) int a[] = {1,2,3,4,5,6,7,8,9,10}
초기값의 수가 배열의 길이가 된다 

지정 초기화(Designed Initializers)
배열에서 몇몇 요소를 명시적으로 초기화할 경우에 다음과 같이 한다
ex) int a[15] = {0,0,29,0,0,0,0,00,7,0,0,0,048}
하지만 큰 배열의 경우 지루하고 오류가 발생하기 쉽다
C99에서는 이 문제를 해결하기 위해 다음과 같은 방법이 가능하다
ex) int a[15] { [2] = 29 , [9] = 7 , [14] = 48}
여기서 대괄호 안의 숫자는 desinator로 불린다 짧고 읽기가 쉽다는 장점이 있다 또한 요소 안의 숫자는 의미가 없다
ex) int a[15] = {[14] = 48, [9] = 7,  [2] = 29};
designator는 반드시  정수 상수 표현식이어야 한다 그리고 배열의 길이가 n이면 designator는 0부터 n-1까지 숫자가
올 수 있다 배열 길이가 생략되어있으면 음수가 아닌 아무 정수가 올 수 있다 컴파일러는 가장 큰 수를 
배열의 크기로 지정한다 또한 오래된 방식을 같이 사용할 수 있다
ex) int c[10] = {5,1,9,[4] = 3, 7,2,[8]=6} '

배열에서 sizeof연산 사용
sizeof연산자는 배열의 크기를 결정할 수 있다 int형 배열 a이 크기가 10이라면 sizeof(a)는 보통 40이다 
sizeof를 통해 배열 요소의 크기를 측정할 수도 있다  
ex) sizeof(a) / sizeof(a[0])
배열의 길이가 필요할 때 다음과 같은 표현식을 사용한는 프로그래머들도 있다
ex) for(i = 0; i < sizeof(a) / sizeof(a[0]); i++)  a[i] = 0;
이렇게 하면 배열의 길이가 변해도 수정을 할 필요가 없게된다 macro를 사용하여 배열의 길이를 나타내는 것도 같지만
sizeof가 매크로 이름을 기억할 필요가 없어더 좀 더 좋다
이런 방법은 경고가 출력될 수 있는데 i는 int이지만 sizeof는 size_t 자료형이기 때문이다 
경로를 피하려면 다음과 같이 하면된다
ex)for(i = 0; i < (int)(sizeof(a) / sizeof(a[0])); i++)
이것이 다루기 어려우면 매크로를 사용하면 된다
ex) #define SIZE ((int) (sizeof(a) / sizeof(a[0])))

다차원 배열 (Multidimensional Arrays)
배열은 어느 차원의 숫자도 가질 수 있다 2차원 배열은 다음과 같이 선언한다
ex) int m[5][9] 해당 배열은 5개의 행과 9개의 열을 가진다 각 행과 열을 0부터 시작된다 
배열에 i행 j열에 접근하기 위해서는 m[i][j]와 같이 사용해야 한다 
m[i]는 행을 선택하고 m[i][j]는 i행에 있는 j열을 선택한다
m[i][j]대신 m[i,j]는 사용할 수 없다 m[i,j]는 m[j]와 같다
보통 2차원 배열은 테이블 형태로 시각화하지만 컴퓨터 메모리에 저장은 행 우선 순서로 저장된다 
ex)  m[0][0]  m[0][1] m[0][2]  m[1][0] m[1][1] m[1][2]  m[2][0] m[2][1] m[2][2]    int m[3][3]일떄 다음과 같이 저장
반복문이 배열에 편리한것처럼 중첩 반복문은 다차원 배열에 이상적이다 다차원 배열의 모든 요소에 접근하려면 다음과 같이 한다
ex) double i[10][10] for(row = 0; row < 10; row++){ for(col = 0; col < 10; col++) ident[row][col]}}
다차원 배열은 다른 프로그래밍 언어보다 덜 중요하다 C는 더 유연한 방법인 포인터 배열을 제공하기 떄문이다 

다차원 배열 초기화 
2차원 배열은 1차원 배열을 초기화 했던것을 중첩해서 초기화 할 수 있다
ex) int m[3][3] =  {  { 1,1,1,} , {2,2,2} , {3,3,3}}
더 고차원의 배열도 다음과 같이 초기화 할 수 있다 
C는 다차원 배열을 초기화 하는 다양한 방법을 제공한다 
- 초기화 요소가 다차원 배열 수보다 크지 않으면 요소들은 0으로 초기화된다 
- 내부의 중괄호는 생략이 가능하다  ex) int m[3][3] = {1,1,1,3,3,3,2,2,2} 컴파일러가 한 행을 채우면 다음 행으로 넘어간다 
중괄호 생략은 추가 요소가 남은 초기화에 영향을 끼칠 수 있어서 위험하다 어떤 컴파일러들은 생략하면 경고를 출력한다 
C99의 desingated초기화는 다차원에서도 사용이 가능하다 
ex) int m[2][2] = {[0][0] = 1 , [1][1] = 2}  지정하지 않은 값은 0이된다

배열 상수(Constant Array)
어느 배열이든 상수로 만들 수 있다 배열 선언 앞에 const를 붙이면 된다
ex) const char hex_chars[] = ...
상수로 선언된 배열은 수정이 불가능하다  상수로 배열을 선언하는 것은 두 이점이 있는데 
수정을 하지 않는 배열이라는 것을 알 수 있고 수정하는 경우 컴파일러가 에러를 발견해준다
const선언은 배열에 저한되지 않고 어느 변수에 사용할 수 있다 

C99에서 배열 변수의 길이 (Variable-Length Arrays)
배열의 길이는 상수 정수가 들어가야 하지만 C99에서는 상수가 아닌 것도 가능하다 
ex) int n;  scanf("%d", &n) ; int a[n];
a는 배열 변수 길이(VLA)의 예시이다 VLA의 길이는 프로그램이 컴파일 될때까 아닌 실행될 때 계산된다 
이것의 주요한 이점은 배열의 길이를 설정할 필요가 없다 대신 얼마나 많은 요소가 필요한지 프로그램 
스스로 계산할 수 있어야 한다 VLA는 하나의 변수 뿐만 아니라 표현식도 가능하다 
ex) int a[3*i+5];  int b[j+k];      int c[m][n]
VLA로 선언한 배열은 초기화할 수 없다 이것은 함수에서 자주 사용된다 

배열이 1이 아닌 0부터 시작하는 이유는 컴파일러를 더 간단하게 만들고 더 빠르다 
배열을 복사할 때는 반복문을 사용하여 요소를 복사해야 한다
ex) for(i = 0; i < N; i++) a[i] = b[i]       a=b  <- 이거는 잘못된 방법이다 
다른 방법도 있는데 <string.h>헤더의 memcpy를 사용하는 것이다 해당 함수는 low-level함수이고 
한 위치로부터 다른위치로 byte를 간단히 복사한다 
ex) memcpy(a,b , sizeof(a));
많은 프로그래머들은 memcpy를 선호한다 왜냐하면 일반 반복보다 더 빠르기 때문이다 

Chap9 Functions

C에서 함수는 수학의 함수와 항상 비슷하지는 않다 항상 필요하지 않고 항상 계산하는 것은 아니다 
함수는 C프로그램을 구성하는 블록이다 각 함수는 작은 프로그램이다  
함수를 사용하면 프로그램을 작은 조각으로 나눌 수 있고 이해하고 수정하기 쉬워진다 
또한 코드 복사를 막을 수 있고 함수는 재사용이 가능하다 

함수 정의와 호출(Defining and Calling Functions)
함수의 정의는 다음과 같이 한다
ex) double average(double a , double b) {  return ( a + b ) /2;}  
처음에 있는 double은 average함수의 리턴 타입이다 함수가 호출되고 반환하는 데이터의 자료형을 나타낸다 
a와 b는 함수의 파라미터이고 함수가 호출될 떄 전달되는 두 숫자를 나타낸다 파라미터는 반드시 자료형을 가져야 한다
또한 함수가 호출될때 초기값을 가진다 
모든 함수는 중괄호로 묶인 실행부분을 가지고 있다 return문을 실행하면 해당 값이 호출된 곳에 반환된다
함수를 호출하기 위해서는 함수 이름을 써야한다 
ex) average( x, y); 이렇게 하면 average함수가 호출된다 
또한 매개변수가 필요한 함수라면 인수를 넣어야한다 인수로 x와 y를 넣으면 값이 복사되어 파라미터 a,b에 들어간다 
그 후 함수의 내용을 실행한다 인수는 변수일 필요가 없다 어떠한 자료형 어떠한 표현식도 들어갈 수 있다
ex) average(5.1, 8.9 ) average(x/2, y/3);
또한 함수는 반환값이 필요한 어디든지 들어갈 수 있다
ex)printf("%g", average(x,y)); 이렇게 하면 다음과 같이 동작한다
1. average함수가 인수 x,y와 함꼐 호출된다
2. x,y는 a,b에 복사된다
3. average함수는 평균을 반환하는  return문을 실행한다 
4. printf가 출력한다 average함수의 반환값을 (함수의 반환값은 printf함수의 인수가 된다)
반환값은 어디서나 저장되지 않는다 위의 경우는 출력하고 값은 버려진다 반환값을 나중에 사용하기 위해서는
변수에 넣어야 한다
ex) avg = average(x,y);
모든 함수는 반환값이 있지 않다 반환이 없으면 리턴 타입으로 void를 적어야 한다 
또한 어떤 함수는 파라미터가 없다 파라미터가 없으면 void를 적어야한
ex) void print_pun(void){ printf("내용");

함수 정의(Fucntion Definitions)
함수 정의는 다음과 같이 한다 
return-type  fucntion-name(parameter){
	deckarations
	statements
}
여기서 return-type은 함수가 반환하는 값의 자료형이다 다음과 같은 규칙을 따른다
 - 함수는 배열을 반환할 수 없지만 다른 자료형은 제한이 없다
 - return-type이 void면 함수는 값을 반환하지 않는것을 나타낸다 
 - C89에서 retur-type을 생략하면 int로 되는데 C99에서는 생략을 하면 안된다
몇 프로그래머는 리턴 타입을 위에 놓는다
double
average(double a, double b){  }
이런 스타일은 unsigned long long int처럼 자료형이 길떄 좋다 
함수 이름 뒤에는 파라미터가 오는데 각각 파라미터는 앞에 자료형이 와야한다 그리고 파라미터는 쉼표로 분리된다
만약 파라미터가 없다면 파라미터가 오는곳에 void를 적어야 한다 
ex) double average(double a,b)  -> 자료형이 같다고 자료형을 묶어서 사용하는 것은 잘못된 표현이다
함수의 body는 선언과 문이 포함될 수 있다 
ex) double average(parameter){  double sum; sum = a + b; return 1;}
함수 내부에서 호출된 변수는 다른 함수에서 수정이나 실행이 불가하다 
C89에서는 변수 선언이 앞에 와야했지만 C99에서는 선언과 문이 섞여도 된다  변수 선언전에 사용은 안된다
return type이 void면 함수 body는 비어있어도 된다 

함수 호출(Function Calls)
함수 호출은 함수 이름과 파라미터에 동봉되는 인수가 필요하다
ex) average(x,y)  print_fun();
인수가 필요없어도 괄호가 없으면 호출되지 않는다  
void함수의 뒤에는 세미콜론이 붙어야 한다 void이외의 함수는 값을 생산하기 때문에 변수에 저장될 수 있고
검사하거나 출력 등 어떠한 방식으로 사용될 수 있다
ex) avg = average(x,y) if(average(x,y) >0 )  printf("%g", average(x,y));
void가 아닌 함수는 필요하지 않으면 값은 버려도 된다 
ex) average(x,y);
반환값을 버리는 것은 특이한 행동이지만 어떤 함수에서는 당연한 행동이다 대표적으로 printf가 있다
ex) num = prinf("내용"); 이렇게 하면 num에는 9가 들어가는데 대부분 이 숫자에는 관심이 없기 때문에 반환값을 버린다 
의도적으로 반환값을 버리는 것을 명확히 하기 위해 함수 호출 앞에 (void)를 붙일 수 있다 
함수에는 return이 여러개 들어갈 수 있는데 호출을 한번만 가능하다 return문이 호출되면 값이 반환되고 함수가 종료된다

함수 선언(Function Declarations)
함수의 정의의 위치는 어디에 있어도 상관이 없다 main함수 밑에 함수를 정의해도 된다 
하지만 main에서 main함수 밑에 있는 함수를 호출 했을 때 컴파일러는 함수에 대한 정보가 없다 
그러나 컴파일러는 에러를 출력하는 대신 int를 반환한다고 가정한다 이를 컴파일러가 함수를 암시적 선언한다고 한다
컴파일러는 함수에 옳바른 인수를 넣었는지 알수 없다 나중에 컴파일러가 함수를 만났을 때 
컴파일러는 잘못된것을 알아차리고 에러메시지를 출력한다 
함수를 정의하기 전에 호출되는 문제를 해결하기 위해서 함수를 선언 이전에 놓기도 한다 하지만 항상 가능한 것이 아니고
이해하기 어렵게 만들기도 한다 C는 더 나은 해결책을 제공하는데 함수를 호출하기 전에 함수를 선언하는 것이다 
함수 선언은 컴파일러가 함수 정의를 간단하게 알 수 있게 한다 함수 선언은 함수 정의의 첫 줄에 세미콜론을 추가한 것과 유사하다
ex) return-type function-name(parameters);
함수 선언은 반드시 함수 정의와 일치해야 한다 이러한 함수 선언은 fucntukn prototpye으로도 알려져있다
함수가 어떻게 호출되는지 완벽한 설명을 제공한다 여기서 함수 파라미터의 이름은 없어도 되지만 자료형은 필수이다
ex)double average (double , double);
하지만 생략하지 않는것이 좋다 이름을 통해 나중에 어떤 목적인지 알 수 있고 순서도 알 수 있기 때문이다 
생략을 선호하는 프로그래머도 있다 C99는 함수선언이 어느 함수의 호출보다 우선해야한다는 규칙을 채택했다

인수(Arguments)
파라미터는 함수 정의에서 나타난다 그것들은 함수가 호출되었을 때 값을 나타내는 더미 이름이다 
인수는 함수를 호출할 때 나타내는 표현식이다 구분이 중요하지 않으면 인수라고 부른다 
C에서 인수는 값에 의해 전달된다(passed by value) 함수가 호출되었을 때 각각 인수가 
계산되고 값이 파라미터에 들어간다 파라미터는 복사한 값을 가지고 있어서 파라미터의 값이 변경되어도 
인수에는 영향을 주지 않는다 
값에 의한 전달은 장점과 단점이 있다 파라미터의 수정은 인수에 영향을 주지 않아서 필요한 변수의 수를 줄일 수 있다
값에 의한 전달은 특정 종류의 함수의 작성을 어렵게 만들기도 한다 return값이 2개가 필요할 때 등 이런 문제가 발생한다 

인수 전환(Argument Conversions)
C언어는 파라미터와 일치하지 않은 자료형의 인수를 허용한다 이 규칙은 컴파일러가 함수 선언을 봤는지 아닌지에 따라 다르다
 - 컴파일러가 함수 선언을 호출전에 마주친 경우  : 인수의 값은 파라미터의 자료형으로 변환된다
 - 컴파일러가 호출 전에 함수 선언을 마주치지 않은 경우 : 컴파일러는 default argument promotion에 따른다 
 float는 double로 바뀌고 short과 char는 int형으로 바뀐다 

배열 인수(Aarray Arguments)
배열은 인수로 종종 사용된다 함수의 파라미터가 일차원 배열일 때 배열의 길이는 지정하지 않아도 된다
ex) int f (int a[]){}  하지만 C는 함수에 전달되는 배열의 길이를 결정하는 쉬운 방법은 제공하지 않는다 
sizeof를 사용하면 배열 변수의 길이를 결정할 수 있지만 배열 파라미터에는 옳바른 답을 주지 않는다
ex) int f(int a[]){ int len = sizeof(a) / sizeof(a[0]);  }
배열의 길이를 결정할 떄 다른 파라미터 값으로 배열의 길이를 결정할 수도 있다 
ex) int sum_array(int a[] , int n){ }   이 함수의 선언은 다음과 같이 할 수 있다
ex) int sum_array(int a[], int n);   or  int sum_array(int , int);
함수에 배열을 전달할 때 배열 이름 뒤에 대괄호를 붙이면 안된다
ex) total = sum_array(b[] , LEN)  <- 잘못된 함수 호출
배열 인수에서 중요한 점은 함수를 호출할 떄 배열의 길이가 옳바른지 확인할 방법이 없다 
b배열이 100개의 숫자를 저장할 수 있을 때 50개만 저장한다면 이렇게 하면된다
ex) total = sum_array(b,50);     나머지 50개ㅐ의 요소는 무시된다 
하지만 함수에게 배열의 길이를 원래 길이보다 더 길다고 전달하면 안된다 
ex) total = sum_array(b, 150) 이렇게 하면 undefined행동을 야기한다
함수에서 요소를 변경하는 것은 허용되고 배열 파라미터를 바꾸면 인수에도 그것이 적용된다 
파라미터가 다차원 배열이라면 첫번째 배열만 생략이 가능하다 
ex) int sum_two_array(int a[][LEN], int n);
임의의 숫자를 다차원 배열에 적용하지 못하는것은 성가시다 하지만 포인터 배열을 통해 이를 해결 할 수 있다 

배열 파라미터 변수의 길이(Variable-Length Array Parameters)
C99에서 배열 인수에 대해 여러가지가 추가되었다 첫째 상수가 아닌 표현식을 사용하여 배열의 길이를 지정하는 것과 관련이 있다
배열 길이를 파라미터를 통해 전달할 떄 배열 크기를 해당 파라미터로 함으로써 크기를 명확하게 할 수 있다
ex) int sum_array(int n, int a[n]){..}
첫 파라미터n의 값은 두번쨰 파라미터의 길이를 특정한다 그리고 n이 앞으로 가는 순서는 중요하다 
ex) int sum_array(int a[n] , int n) <- 다음과 같이 사용하면 안된다 
함수 프로토타입을 작성하는 여러 방법이 있다 하나의 방법은 함수 정의처럼 한다
ex) int sum_array(int n , int a[n]);
다른 방법은 길이에 *을 사용하는 것이다 
ex) int sum_array(int n, int a[*]);
*을 사용하는 것은 파라미터 이름은 함수 선언에ㅔ서 선택적이라느느 것이다 첫 파라미터 이름이 생략되면 
배열의 길이가 n이라는것은 알수 없지만 *은 앞 파라미터가 배열의 길이와 관련되었다는 증거가 된다 
파라미터 배열을 선언하는 것처럼 대괄호를 비게 할 수도 있다
ex) int sum_array(int n, int a[]); int sum_array(int , int[]);
빈칸으로 두는 것은 n와 a사이의 관계성을 드러낼 수 없어서 좋지 않다 
일반적으로 파라미터 배열의 길이 부분은 어느 표현식이든 올 수 있다 
ex) int concatente(int m, int n, int a[m], int b[n] , int c[m + n)
배열 파라미터의 변수 길이는 1차원 배열에서는 사용이  한정된다 
다차원 배열에서는 가장 유용한데 원래 다차원배열에서 첫번쨰를 제외하고는 빈칸으로 못 두기때문에 
함수가 열의 개수에 상관없이 일반화할 수 있다 
iex)int sum_two_dimensional_array(int n, int m, int a[n][m]){ ...}
이 함수의 프로토타입은 다음과 같다
int sum_two_dimensional_array(int n, int m, int a[n][m]);
int sum_two_dimensional_array(int n, int m, int a[*][*]);
int sum_two_dimensional_array(int n, int m, int a[][m]);
int sum_two_dimensional_array(int n, int m, int a[][*]);

배열 파라미터 선언에서 static사용(Using static in Array Parameter Declarations)
C99는 배열 파라미터 선언에서 static을 사용하는 것을 허용한다 
ex) int sum_array(int a[static 3], int n)  여기서 배열a의 최소 길이가 3이라는 것을 의미한다 
static을 사용하는것은 프로그램에는 아무 영향을 미치지 않는다 C컴파일러가 배열에 접근할 떄 더 빠른
설명을 생성하는 힌트를 제공한다  (컴파일러가 배열의 최소 길이를 알면 함수를 호출할 때 prefetch하여 정렬할 수 있다)
배열이 다차원이라면 static은 첫번쨰 배열쪽에서만 사용할 수 있다 

Compound Literals 
함수의 첫 파라미터가 배열이면 함수를 호출 할 떄 첫번쨰 인수는 보통 배열의 이름이 된다 
이것의 문제는 배열은 변수로 선언되어야 하고 호출보다 앞서서 초기화 되어야 한다 함수 호출 목적으로만
사용한다면 성가신 일이된다
C99에서는 compound Literals을 사용함으로서 이를 피할 수 있다 compound Literal은 포함하고 있는 요소를
간단히 명시함으로서 이름없는 배열을 생성할 수 있다 
ex) total = sum_array((int []) {3,0,3,4,1,}, 5);
여기서 복합 리터럴을 통해 5개 정수를 포함하는 배열을 생성했다 리터럴 내부의 숫자에 의해 배열의 길이가 결정되기 떄문에
길이를 명시하는 것은 선택적이다 
복합 리터럴은 배열 초기화와 같은 규칙을 따른다 때문에 복합 리터럴은 초기화 되지 않은 요소는 0으로 된다
또한 함수 내부의 복합 리터럴은 상수가 아닌 표현식을 사용할 수 있다
ex) total = sum_array(int [20]) {2*i, i+j , j *k }, 3);
그리고 파라미터 앞에 const를 붙여서 읽기전용으로 만들수도 있다
ex) (const int []){5,4}

return 문(The return Statement)
void함수가 아니면 반드시 리턴문을 사용하여 어떤 값을 반환하는지 사용해야한다
ex) return expression; 
표현식은 보통 상수 또는 변수이다 더 복잡한 표현식도 가능하다 예를들어 삼항 연산자도 올 수 있다
ex)return n >= 0 ? n : 0; 이구문이 실행되면 n>=0 ? n:0이 면저 계산되서 true면 n아니면 0이 반환된다 
return문의 표현식 자료형이 함수의 return type과 일치하지 않으면 표현식은 리턴 타입으로 암시적으로 변환된다 
예를 들어 리턴 타입은 int이고 return문 표현식에 더블이 있으면 표현식은 int로 변환된다 
return문은 void함수에서도 나타날 수 있는데 표현식은 주어지지 않는다
ex) return;  여기서 표현식을 주면 complie-time error가 발생할 수 있다 
void함수에서 마지막 구분이 실행되고 자동으로 반환되기 떄문에 return은 중간에 반환시킬것이 아니라면 불피요하다 
void함수가 아니라면 return실행에 실패하고 끝에 도달하면 undefined behavor가 된다
몇 컴파일러는 이런 상황이 발생할 수 있으면 경고를 출력한다 

프로그램 종료(Program Terminaation)
메인 함수도 함수여서 리턴 타입을 가져야 한다 일반적으로 메인함수의 리턴타입은 int이다 
오래된 C프로그램은 종종 메인 함수의 리턴 타입을 생략한다 기본 리턴값이 int기 때문에
ex) main(){...}
리턴 타입을 생략하는것은 C99에서는 규칙에 반한다 파라미터에 void를 생략하는 것은 문제는 없지만 
명시하는 것이 좋다 
메인 함수가 반환하는 값은 상태 코드이다 프로그램이 종료될 떄 검사된다 
main이 0을 반환하면 정상적으로 종료된다 비정상적으로 종료되면 0이 아닌 다른 값을 리턴한다 
모든 프로그램에서 상태코드를 반환하는 것은 좋은 습관이다 

종료 함수 (The exit Function)
메인 함수에서 return문을 사용하는 것은 프로그램 종료의 한 방법이다 다른 방법은 exit함수를 사용하는 것이다
<stdlib.h>헤더에 속해있는데 인수는 main의 리턴 값과 동일한 의미를 가진다 일반적으로 종료하려면 0을 넣는다
ex) exit(0) 이것을 이렇게 사용해도 된다   exit(EXIT_SUCCESS)
exit(EXIT_FAILURE) <- 이렇게 사용하면 비정상적인 종료를 나타낸다 
이것들은 <stdlib.h>에 정의된 매크로이다 일반적인 값은 0 과 1이다
프로그램 종료 방법으로써 return과 exit는 밀접하게 관련이 있다 하지만 두 문의 차이점은
exit는 프로그램 어디서든지 호출해도 종료되지만 return은 메인 함수에서만 종료된다 

재귀(Recursion)
함수가 자기 스스로를 호출하면 재귀함수가 된다 
ex) int fact(int n ) if(n<=1) return 1; else return n * fact(n-1); 
어떤 프로그래밍 언어는 재귀함수에 많이 의존하지만 어떤 프로그래밍 언어는 허용도 되지 않는다 
C는 중간지점인데 C는 재귀함수를 허용하지만 자주 사용하지는 않는다 
재귀함수에서 return부분은 중요한데 보통 파라미터의 값을 체크해서 재귀를 할지 리턴을 할지 체크한다 

퀵정렬 알고리즘(The Quicksort Algorithm)
재귀함수는 스스로를 두번 이상 사용하는 복잡한 알고리즘에서 유용하다 재귀함수는 분할 정복 알고리즘에서 자주 사용된다
분할 정복은 큰 문제를 작은 조각으로 나누고 동일한 알고리즘으로 해결을 한다 분할정복의 고전적인 예로 
잘 알려진 퀵정렬 알고리즘이다 해당 알고리즘은 다음과 같이 동작한다 
1. 배열의 요소e를 선택하고 요소 1, ... , i-1이 e보다 작거나 같도록 재배열되고 i는 e를 포함하고 요소 i+1, ...n은 e보다 크거나 같다
2. 1 ...  i-1을 퀵정렬을 재귀적으로 사용하여 정렬한다
3. i+ 1, ... n을 퀵정렬을 재귀적으로 사용하여 정렬한다 
1번에서e는 적절한 위치에 있다 e의 왼쪽의 요소는 e보다 작거나 같아서 요소들은 2단계에서 정렬되어 올바른 위치가된다
오른쪽도 마찬가지로 적용된다 
퀵정렬에서 1번은 아주 중요하다 배열을 나누는 다른 방법보다 도 좋은 방법이 있기 때문이다 우리는 이해는 쉽지만
가장 효과적이지는 않은 방법을 사용한다 
이 알고리즘은 low, high의 두 마커가 존재한다 처음에 low를 처음 요소 high를 마지막 요소로 한다 
처음 요소는 일시적인 위치에 복사하고 배열에 구멍을 낸다 파티션 요소 생성
다음에는 high를 파티션 요소보다 작은 지점을 가리킬떄까지 왼쪽으로 이동한다 그리고 high가 가리키는 지점의 요소를
low가 가리킨 구멍에 복사한다 그리고 high가 가리키는 지점에 새로운 구멍을 만든다 이후에 
low에서 왼쪽으로 오른쪽으로 가면서 파티션 요소보다 큰 값을 찾는다  low와 high가 번갈아가면서 이를 반복하고 
low와 high가 중앙에서 만날때까지 반복한다 
ex)  
12  3  6  18  7  15  10  의 배열이 있다
low                     high
처음에 low소를 빼고 구멍을 만든다
   3   6   18  7   15   10   p 12
low                       high
high값이랑 비교하고 10이 12보다 작기 때문에 10을 구멍 위치로 옮기고 high에 구멍을 만든다
10   3   6   18   7   15     p12
low                     high
그리고 low부터 탐색해서 더큰값이 올때까지 탐색한다
10    3   6   18   7   15      p12
                 low           high
18이 더크기때문에 18을 high의 구멍에 옮기고 18의 위치에 구멍을 만든다 그리고 다시 high를 탐색한다
10    3    6       7    15    18  p12
                low       high
7이 12보다 작기 때문에 high가 7의 위치가 되고 빈칸에 7을 넣는다
10    3    6   7        15    18    p12
                 low high
다시 low를 탐색하면 low와 high가 같아지게 된다 이 지점에 12를 넣는다 이렇게 하면 12는 제자리를 찾게된다
10   3    6    7    12    15    18
이제 12의 왼쪽과 오른쪽을 같은 방법을 사용해서 정렬을 하면된다 

C언어는 함수의 정의가 또다른 함수의 내부에서 나타나는것을 허용하지 않는다 
컴파일러가 괄호없는 함수 이름을 허용하는 이유는 괄호가 없으면 함수에 대한 포인터로 생각한다 
함수에 대한 포인터는 정상적인 사용이여서 오류가 아니다 
함수 선언 부분에서 파라미터 이름과 함수 정의 부분에서의 파라미터 이름은 일치할 필요는 없다 
파라미터 이름을 생략하는것은 방어적 목적이다 매크로 이름과 파라미터 이름이 같으면 파라미터 이름은
전처리기에 의해서 대체되어 피해를 입게된다 
함수 내부에서 다른 함수를 선언하는것도 가능은 하다 ex) int main(void) double average(double a , double b);
함수의 반환 자료형이 같을 때 함수의 선언은 결합될 수 있다 
ex) void print_pun(void) , print_count(int n);      double x, y, average(double a, double b);
하지만 이런 선언은 혼란을 야기해서 좋은 방법은 아니다 
함수 파라미터 배열에 숫자를 넣을 수는 있지만 컴파일러는 이를 무시한다
ex) double inner(double a[3], double b[3]); 
다차원 배열 파라미터에서 처음 이외에는 숫자를 명시해야하는 이유는 배열이 함수로 전달될 때 배열의 첫 번쨰 요소의
포인터를 부여한다 그리고 a[i]= 0와같은 배열이 사용될때  i* 자료형  +  a포인터 위치와 같은 방법으로 접근을 하는데 
이 계산은 a의 길이에 의존하지 않는다 
a[i][j]가 있을 때 
1.  a에서 하나의 크기 row에  i를 곱한다 
2.  a주소에 1번을 더한다
3.  자료형 * j를 한다
4. 3결과를 2에 더한다 
이렇게 계산을 하기 때문에 다차원 배열일 때 반드시 뒤 차원의 크기를 알아야 하기때문에 다차원 배열 파라미터에서 1차원 이상은 크기를 명시해야한다
프로그램이 정상적으로 종료되었는지 메인함수의 리턴값을 확인하는 방법은 운영체제마다 다르다 많은 운영체제는 
"batch file", "shell scrtip"에서 값 검사를 허용한다 
몇몇 컴파일러는 main에 return구문이 없으면 "control reaches end of non-void function"에러 메시지를 출력한다 
이떄 return문을 넣으면 해결된다 

Chap10  Program Organization

지역변수 (Local Variables)
변수를 함수 내부에서 선언하면 지역 변수가 된다 
ex) int sum_digit(int n ) { int sum = 0;    <- 지역변수 }
지역변수는 다음과 같은 특성을 가진다 
 - 자동 공간 지속(automtic storage duration)  : 공간 지속은 프로그램 실행중에 변수가 존재하는 공간을 말한다 
지역 변수의 공간은 자동으로 할당된다 함수가 호출되었을 때 그리고 함수가 반환될 때 할당이 해제된다 
그래서 지역변수는 자동 공간 지속을 가진다고 말한다 함수가 다시 호출되었을 때 지역변수가 이전 값을 가진다는 보장은 없다 
 - 블록 범위(Block scope) : 변수의 범위는 변수가 참조될 수 있는 부분이다 지역변수는 블록 범위를 가지는데 
 지역 변수는 함수의 끝부분 까지만 볼 수 있다 지역 변수는 함수넘어서 확장할 수 없어서 다른 함수에서 같은 이름이 사용 가능하다 
C99에서 변수 선언은 처음에 올 필요가 없어서 지역 변수는 아주 작은 범위를 가지는게 가능하다 

고정 지역 변수 (Static Local Variable)
지역변수 선언 앞에 static을 넣으면 고정 저장 지속(Static Local Variable)을 가지게 한다
고정 저장 지속을 가진 변수는 영구적인 저장 공간을 가진다 그래서 실행 내내 값을 유지한다 
ex) void f(void) { static int i ; ...}   
지역변수가 static으로 선언되었기 때문에 프로그램 실행 내내 같은 공간을 가진다 
고정 지역 변수도 블록 범위를 가지기 때문에 다른 함수에서는 사용할 수 없고 다른 함수에서 같은 이름을 사용할 수 있다 

파라미터(Parameters)
파라미터는 지역변수와 같은 특성을 가진다 다른점은 각각 파라미터는 함수가 호출될 때 초기화 된다는 점이다 

외부 변수(External Variables)
인수를 전달하는것은 함수에 정보를 전달하는 하나의 방법이다 함수는 외부 변수를 통해서도 정보를 전달할 수 있다
외부변수는 함수 바깥에서 선언된 변수이다 외부 변수는 다음의 특성을 가진다 
 - 고정 저장 지속(Static storage duration) :   외부 변수는 고정 저장 지속을 가진다 static지역 변수와 같이 저장된 값은 항상 지속된다 
 - 파일 범위 (File scope) : 외부변수는 파일 범위를 가진다 선언부터 파일 끝까지 사용이 가능하다 그래서 외부 변수는 선언 이
후의 함수에는 접근이 가능하다 

스택은 배열처럼 같은 자료형의 데이터들을 저장할 수 있다 그러나 스택의 사용은 한정된다
스택의 끝부분에 값을 추가하는 push와 끝 부분의 값을 제거하는 pop만 가능하다 
C에서 스택을 구현하는 하나의 방법은 content배열에 항목을 저장하는 것이다 
top이라고 불리는 분리된 변수가 stack의 top을 가리킨다 
스택이 비어있으면 top은 0을 가리킨다 push는 content의 top부분에 값을 추가하고 top을 증가시킨다
pop은 top을 감소시킨다 이때 contents와 top을 외부 변수로 만들어 스택을 구현할 수 있다 

외부 변수의 창반양론(Pros and Cons of External Variables)
외부 변수는 많은 함수에서 변수를 공유할 때 편리하다 
하지만 파라미터를 이용하여 값을 공유하는 것이 더 좋다 이유는 다음과 같다 
 - 외부변수를 프로그램을 유지보수 하는동안 변경한다면 모든 함수를 체크해야한다 
 - 외부변수에 잘못된 값이 할당되면 어디 함수에서 잘못되었는지 찾기가 힘들다 
 - 외부변수에 의존하는 함수는 재사용하기가 어렵다 
많은 프로그래머들이 외부 변수에 의존하는데 하나의 남용은 다른 목적을 가진 함수에서 같은 외부 변수를 사용하는것이다
for에서 i를 주로 사용하는데 이것을 외부변수로 만들면 오해하기가 쉬운데 변수의 사용이 관련되어있다고 생각할 수가 있다
지역변수 대신 외부변수를 사용한느 것은 버그를 생성할 수도 있다 
ex) int i void print_one(void) for (i = 1; i <= 10; i++ ) print    void print_two(void) for(i = 1; i <= 10; i++){ print_one(); print();
다음과 같은 경우 i를 두 함수에서 모두 사용하는데 한 함수가 다른 함수를 호출해서 i값이 첫 함수를 호출했을 떄 10이 넘어가서
두번째 함수의 반복은 한번만 실행되게 된다 

블럭(Blocks)
다음 형태의 복합 구문이 있다
ex) {statements} 
C언어는 선언을 포함하는 복합 구문을 허용한다 
ex) {declaration  statement} 
복합 구문을 설명하기 위해 블록이라는 용어를 사용한다 
ex) if( i > j ) {    int tmp = i; i = j; j= tmp;
기본적으로 블록에서 생성된 변수의 변수의 공간 지속은 자동적이다 
변수는 블록을 들어갈 때 할당되고 블록을 빠져나오면 할당이 해제된다
블록 밖에서는 참조될 수 없다 static으로 선언하면 고정 공간 지속이 된다 
함수의 body는 블록이다 블록은 함수 내에서 일시적으로 변수를 사용하기에 유용하다 
블록 내에서 임시 변수는 두 장점이 있다 
1.  함수의 시작부분에 변수를 선언해서 어지럽히는것을 피할 수 있다
2. 이름 충돌을 줄일 수 있다

Scope (범위)
C프로그램에서 동일한 식별자는 여러가지 다양한 의미를 가진다 C의 범위 규칙은 프로그래머가 
특정 지점에서 어떤 의미를 가지는지 결정할 수 있다 
가장 중요한 범위 규칙은 블록 내에서 선언한 이름 식별자는 블록 끝까지 오래된 식별자를 숨기고 새로운 
식발자가 새로운 의미를 가지게 한다 아래 예시에서 i는 4가지 다른 의미를 가진다 
ex) int i;   /* 선언1 */  void f(int i){   /*선언2 */ i = 1; }    /*  선언 2 사용 */   void g (void) { int i = 2; /* 선언 3*/
if( i > 0) { /*선언 3 사용  */ int i / * 선언 4 */  i = 3;   /*선언 4 사용* /  }  i = 4  /*선언 3 사용 */
void h (void)  { i = 5; }   /* 선언 1 사용 * /
- 선언 1에서 i는 고정 저장 지속과 파일 범위를 가진 변수이다 
- 선언 2에서 i는 블럭 범위를 가진 파라미터이다 
- 선언 3에서  i는 블록 범위를 가진 변수이다 
- 선언 4에서 i는 블록 범위를 가진 변수이다 
i는 5번 사용되었는데 C의 범위 규칙은 각각 다른 의미를 가지게 결정한다 
- i =1은 선언 2 의 파라미터를 변경한다 선언 2가 선언 1을 숨겼기 때문이다
- i>0은 선언 3을 참조한다 선언 3이 선언 1을 숨기고 선언 2의 범위는 아니기 때문이다 
- i = 3 은 선언 4를 참조한다 
- i = 4 는 선언 3을 참조한다 선언 4의 범위는 끝났기 때문이다 
- i = 5는 선언 1을 참조한다 

C프로그램 구조
지금까지 프로그램들은 다음을 포함하였다
-전처리 지시어( #include , #define)
-자료형 정의
- 외부 변수
- 함수 선언
- 함수 정의
C는 이 항목의 순서에 대해 몇개의 규칙을 부과했다 전처리 지시어는 라인에 나타나기 전까지 효과가 없다,
자료형 이름은 정의되기 전에 사용할 수 없다 , 변수는 선언 이전에 사용할 수 없다 모든 함수는 호출전에 정의하고 선언해야한다
프로그램의 구성에는 여러가지가 있는데 이런 규칙을 지키는 하나의 순서는 다음과 같다
- #include 지시어
- #define 지시어
- 자료형 정의
- 외부 변수 선언
- 함수 선언
- 메인 함수 정의
- 다른 함수 정의
#include는 필요한 여러 정보를 준다  #define은 프로그램 전체적으로 사영될 매크로를 생성한다 
자료형 정의를 외부 변수 선언 위에 두는 이유는 변수 선언을 정의한 자료형으로 할 수 있기 떄문이다
외부 변수 선언은 이후의 함수들이 이용이 가능해진다 
메인함수이외의 함수를 선언하는 것은 컴파일러가 프로토타입 발견 전에 호출되었을 떄 생길 수 있는 문제를 피하게 해준다
함수 정의 전에 주석을 달아 의도를 설명하고 파라미터의 의미를 설명하고 반환 값 그리고 side effect등을 설명하는 것이 좋다 

재귀함수가 호출되었을 떄 복사본은 각각 자동 변수를 만든다 이것은 static변수에는 일어나지 않는다
대신 모든 함수는 같은 static변수를 공유한다 

Chap11 Pointer

포인터는 C의 가장 중요한 것중 하나이다 그리고 중요성때문에 가장 잘못 이해되는 특성이다 

포인터 변수(Pointer variable)
포인터를 이해하는 첫번째 단계는 기계 레벨에서 나타나는 것을 시각화하는것이다
현대 컴퓨터에서 메인 메모리는 8bit의 정보를 저장 가능한 byte로 나누어진다
0  1  0  1  0  0  1  1
각각 byte는 다른 byte와 구별하기 위해 고유한 주소를 가진다 만약 메모리에 n개의 바이트를 가지면
0부터 n-1의 범위를 생각할 수 있다 
실행가능한 프로그램은 코드(C프로그램에서 구문과 일치하는 기계 지시어) 와 데이터(변수)로 구성이 된다 
각 변수는 하나 또는 그 이상의 바이트의 메모리를 가진다 
변수의 첫번쨰 byte의 주소는 변수의 주소이다 먄약 변수i가 2000 , 2001주소를 차지하면 i의 주소는 2000이다
주소는 숫자에 의해서 표현되지만 주소의 범위는 정수와 다르다 그래서 일반 정수에 저장하지 못한다 
그러나 포인터 변수에 주소를 저장할 수 있다 	
변수 i의 주소를 p에 저장할 때 p는 i를 가리킨다고 한다 포인터는 주소일 뿐이고 
포인터 변수는 주소를 저장할 수 있는 변수이다 

포인터 변수 선언(Declaring Pointer Variables)
포인터 변수는 일반 변수와 같이 선언하지만 다른점은 이름 앞에 *을 붙어야 한다
ex) int *p;
이 선언은 p가 int 자료형의 값을 가리킬 수 있는 포인터 변수를 나타낸다 
variable대신 object라는 단어를 사용하는데 p는 메모리 영역을 가리키는 것이지 변수에 속하는 것을 가리키지 않기 떄문이다
포인터 변수는 다른 변수들과 함께 선언할 수 있다
ex) int i, j, a[10], b[20], *p , *q;
C에서 모든 포인터 변수는 특정 자료형 오브젝트만 가리킨다 
ex) int *p  - int형 자료형만 가리킨다    double *q  - double형 자료형만 가리킨다 
참조되는 자료형에는 제한이 없는데 포인터 변수는 다른 포인터를 가리킬 수도 있다 

주소와 간접 연산자(The Address and Indirection Operators)
C는 포인터와 함께 사용되는 한 쌍의 연산자를 제공한다 변수의 주소를 찾기위해 &(주소)연산자를 사용한다
x가 변수라면 &x는 x의 메모리 주소이다 포인터가 가리키는 오브젝트에 접근하기 위해서는 *(간접)연산자를 사용한다
p가 포인터라면 *p는 가리키고 있는 오브젝트를 나타낸다 


주소 연산자(The Address Operator)
포인터 변수를 선언하면 공간은 설정되지만 포인터의 오브젝트는 만들지 않는다
p를 사용하기 전에 초기화하는것은 중요하다 포인터변수 초기화의 한 방법은
변수의 주소를 할당하거나 &연산자를 이용해서 lavalue의 주소를 할당하는 것이다
ex) int i, *p;  ...   p = &i;
i변수의 주소를 p에 할당하면 p는 i를 가리키게 된다 


간접 연산자(The Indirection Operator)
포인터 변수는 간접연산자를 사용하여 오브젝트에 저장되어있는 값에 접근할 수 있다
p포인터가 i를 가리킨다면 다음과 같이 출력할 수 있다
ex) printf("%d\n", *p);  printf는 i주소가 아닌 i의 값을 출력한다
*는 i의 의 역으로 생각할 수도 있다 &는 변수의 포인터를 생성한다 *를 포인터에 적용하면 원래 변수를 가져온다
ex) j = *&i;   이것은 j = i 와 같다 
p가 i를 가리키면 *p는 i의 가명이다 *p와 i가 같은 값을 가질 뿐만 아니라 *p의 값을 바꾸면 i의 값도 바뀌게 된다 
(*p는 lvalue여서 이것을 할당하는것도 가능하다)  
절대 초기화되지 않은 포인터 변수에 간접연산자를 사용하면 안된다 초기화가 안된 p포인터 변수를
어떤 방법으로든지 사용하려고 시도하면 undefined 행동이 된다 
ex) int *p prinft("%d", *p) 쓰레기값을 출력하고 프로그램 충동을 야기하고 다른 영향도 있을 수 있다 
*p에 값을 할당하는 것은 특히 위험하다 p가 유효한 주소를 가진다면 주소에 저장된 값을 수정하려고 할것이다
ex) int *p *p = 1;
이런 할당이 프로그램에 있다면 이상한 행동을 할것이고 운영체제에 이런 코드가 있으면 프로그램은 파괴된다 
컴파일러는 이런 것을 경고할것이고 주의를 기울여야 한다 

포인터 할당(Pointer Assignment)
C는 같은 자료형을 가지고 있다면 포인터를 복사하기위한 대입 연산자를 허용한다 
ex) int i, j , *p , *q ;    p = &i; 포인터 할당의 한 예이다 i주소가 p에 복사된다
q = p  p의 내용을 q르 복사한다 q와 p가 같은것을 가리키게 한다 
여기서 p와 q는 i를 가리키고 *p와 *q를 이용하여 i의 값을 바꿀 수 있다 
ex0 *p = 1;   *q = 2;  여러개의 포인터 변수가 같은 오브젝트를 가리킬 수 있다 
q = p 와  *q =*p를 혼돈해서는 안되는데 첫번째는 포인터 할당이고 두번째는 아니다 
ex) p = &i;   q = &j  i = 1;  *q = *p  이렇게 하면 p가 가리키는 i의 값을 q가 가리키는 j의 값에 복사한다 

포인터 논의 (Pointers as Arguments)
포인터가 어디에 좋은건지에 대한 대답은 한가지가 아니다 포인터는 여러가지 다른 사용방법이 있다 
포인터는 함수의 인수로 사용할 떄 좋다 C의 인수는 값에 의한 전달인데 인수의 값을 바꿀수가 없다 
하지만 포인터는 이 문제에 대한 해답을 제공한다 x값을 넣는 대신 &x를 함수의 인수에 넣음으로써
대응되는 파라미터인 p는 포인터로 선언해야 한다 함수가 호출되었을 때 p는 &x를 가지고 *p는 
x의 가명이 된다 함수 안에서 *p는 x에 대한 간접차모가 되고 함수에서 x를 수정할 수 있게 된다 
ex) void decompose(double x, long *int_part, double *frac_part){ *int_part = (long) x;}
해당 함수의 선언은 다음과 같이 한다 
ex) void decompose(double x, long *int_part, double *frac_part); or  void decompose(double, long * , double *)
해당 함수의 호출은 다음과 같이 한다
ex) decompose(3.14159 , &i, &d);
&연산자가 변수 앞에 있어서 변수의 값이 아닌 포인터가 들어간다 
포인터를 함수의 인수로 사용하는것은 새로운 것이 아닌데 scanf를 사용할 때도 포인터를 사용하였다
ex) int i; scanf("%d", &i); &연산자를 변수 앞에 붙여서 scanf는 변수의 포인터를 전달했다ㅏ
비록 scanf의 인수로 반드시 포인터가 들어가야해도 &연산자가 무조건 필요한 것은 아니다 
ex) int i, *p;  p= &i; scanf("%d", p);   p가 i의 주소를 가지기 떄문에 여기서 &연산을 사용하는것은 잘못된다
함수에 포인터 전달을 실패하면 처참한 결과를 낳는다 함수는 포인터 변수를 예상하지만 값이 들어오면
값을 포인터처럼 사용할 것이다 그렇게 되면 알 수 없는 메모리를 바꾸게 될것이다 

인수를 보고하기 위한 Const사용( Using const to Protect Arguments)
함수를 호출하고 포인터 변수를 전달하였을 때 보통 값을 변경할 것으로 생각한다
ex) f(&x) x의 값을 검사하기 위해 이렇게 사용할 수도 있다 포인터의 이유는 효율성이다 
전달하는 변수의 공간이 크게 필요한다면 변수로 전달하는것은 시간을 낭비하는 것이다 
const를 사용하여 함수에서 포인터로 전달된 값이 변하는 것을 막을 수 있다
const는 파라미터 선언 자료형 전에 넣는다 
ex) void f(const int *p) { } const는 p 포인터가 상수라는 것을 나타낸다 *p를 수정하는것은 에러를 출력시킨다 

반환값의 포인터(Pointer as Return Values)
포인터를 함수에 전달할 수 있을 뿐만 아니라 반환에도 포인터를 사용할 수 있다 이러한 함수는 비교적 일반적이다 
ex) int *max(int *a , *b); {if(*a > *b){ return a;  else return b; 함수를 호출할 떄 int형 2개 포인터 변수를 받는다 
그리고 포인터 변수에 값을 저장한다 
ex) int * p , i, j;  p = max(&i, &j);   함수 호출 후 p포인터는 i또는 j를 가리킬 것이다

해당 함수가 전달된 인수중 하나를 가리키지만 외부 변수나 static으로 선언된 지역 변수도 반환이 가능하다 
절대 자동 지역 변수를 포인터로 반환하면 안된다
ex) inf *f(void){ int i; ... return &i;} 변수 i는 f가 반환디면 존재하지 않고 그렇기 떄문에 i를 가리키는 포인터는 유효하지 않다
포인터는 배열 요소도 가리킬 수 있다 a가 배열이면 &a[i]는 a의 요소 i에 대한 포인터이다 함수가 배열 인수를 가졌을 떄
배열중 하나의 요소를 반환하는 함수는 유용하다 
ex) int  *find_middle(int a[], int n){  return &a[n/2]; }
포인터는 보통 항상 같은 주소를 나타내지만 컴퓨터에 따라 다르다 
*는 사용되는 맥락에 따라서 다양한 의미를 가진다 
ex) int *p = &i 여기서 *는 간접 연산자가 아니라 포인터를 알려주는 기호이다 
파라미터가 const로 된 포인터 변수인 경우 포인터가 가리키는 변수를 변경시킬 수 없지만 포인터 자체는 변경할 수 있다
ex) void f(const int *p) { int j; *p = 0;  <-잘못됨    p = &j  <-  정상코드

chap12 Pointers and Arrays

포인터 연산 (Pointer Arithmetic)
int a[10] , *p;  p = &a[0];  다음과 같이 하면 p가 a[0]을 가리킨다
p포인터가 a의 요소를 가리키는것은 특별한 것이 아니지만 포인터 산술을 p에 수행해서 a의 다른 요소에 접근이 가능하다
C는 3가지 형태의 포인터 연산을 제공한다 
-포인터에 정수 추가
- 포인터에 정수 빼기
- 포인터에서 다른 포인터 뺴기

포인터에 정수 추가(Adding an Interget to a Pointer)
정수 j를 포인터 p에 추가하는 것은 p에서 j만큼 뒤의 요소를 가리키는 포인터가 생성된다
포인터가 a[i]를 가리킨다면 p +j 는 a[i + j]를 가리키게 된다 ( a[i + j]가 존재해야한다)

포인터에 정수 빼기(Substracting anInteger from a Pointer)
p가 a[i]의 요소를 가리킬 때 p에서j를 빼면 a[i - j]의 요소를 가리키게 된다 

포인터에서 다른 포인터 빼기(Subtracting One Pointer from Another)
한 포인터에서 다른 포인터를 뺼 떄 결과는 포인터 사이의 거리이다 
ex) p = &a[5];   q= &a[1];    i = p - q;   (i는 4가된다)    i = q - p (i는 -4가된다)
배열 요소를 ㄱ리키고 있지 않은 포인터를 연산하는 것은 undefined행동을 야기한다
또한 같은 배열이 아닌 포인터끼리의 뺄셈을 하면 undefined가 된다 

포인터 비교(Comparing Pointers)
관계연산자(< <= > >=)와 동등연산자( == , != )를 사용하여 포인터를 비교할 수 있다 
같지 않은 배열에 있는 포인터를 비교하는 것은 의미가 없다 비교의 결과는 배열의 상대적 위치에 의존한다
ex) p = &a[5] ; q = &a[1];     p <= q  <- 0이된다    p >= q <- 1이된다 (뒤에있는 것이 더 큰것으로 판단)

복합 리터럴 포인터 (Pointers to Compound Literals)
복합 리터럴로 만들어진 배열의 요소를 가리키는 포인터는 규칙에 어긋나지 않는다 
복합 리터럴은 이름없이 배열을 만들 수 있는  C99의 특징이다 
ex) int *p = (int []){3,0,3,4,1};  p는 배열의 첫 요소를 가리키게 된다 
복합 리터럴은 배열을 선언하고 포인터를 생성하여 첫 요소를 가리키게 하는 수고를 덜어준다 

배열처리에서 포인터 사용(Using Pointers for Array Processing)
포인터 연산은 반복문에서 포인터 변수를 증가시키면서 배열의 요소에 접근할 수 있게 해준다 
ex) #define N 10  int a[N], sum , *p;   sum = 0; for(p = &a[0]; p < &a[N]; p++) sum += p;
여기에서 p < &a[N] 은 특별한 부분인데 a[N]은 없기 때문에 이상하게 보이지만  규칙에 맞는다 
a[N]를 사용하는것은 a[N]의 값을 검사하지 않기 때문에 아주 안전하다 
배열 첨자 지정을 사용해서 포인터 없이 반복을 작성했었는데 포인터 연산은 실행 시간을 줄일 수 있다는 
주장은 자주 논의되었다 그러나 어떤 컴파일러는 첨자 지정을 사용하는 연산이 더 나은 코드를 생성한다 

*연산과 ++연산의 결합 (Combining the * and ++ operators)
C프로그래머들은 배열 요소를 처리할 때 종종 *연산과++연산을 사용한다 
참조 지정을 사용할 떄 a[i++] = j;이런식으로 배열에 접근하는것을 *p++ = j;와 같이 사용이 가능하다 
++연산의 우선순위가 *보다 우선이여서 컴파일러는 이렇게 본다
*(p++) = j;는 *연산과 ++연산을 결합한 하나의 방법이다 (*p)++와 같이 사용할 수도 있다 
이렇게 사용하면 p가 가리키는 값을 반환하고 그 값을 증가시킨다  다음 표는 *와 ++를 같이 사용하는 모든 경우의 수 표이다
표현			의미
*p++ or *(p++)	후위에 있는 ++연산을 먼저 실행하고 *p를 뒤에 실행한다 p의 값을 반환하고 p를 더한다
(*P) ++  		p의 값을 반환하고 *p의 값을 더한다
*++p or *(++p)     p를 먼저 증가시키고 더한 p주소의 값을 반환한다
++*p or ++(*p)  	*p값을 먼저 더하고 *p값을 반환한다 
이중에서 반복문에서 편리해서 *p++를 가장 자주 사용한다 
ex) p = &a[0];  while(p < &a[N])  sum += *p++;  
*와 --의 혼합은 *와 ++연산과 같은 방법으로 혼합해서 사용할 수 있다 

배열 이름을 포인터로 사용( Using an Array Name as a Pointer)
포인터 연산은 배열과 포인터의 관계중 하나의 방법이다 다른 주요한 관계는 배열의 이름이 배열의 첫 번째 요소를
가리키는 포인터로 사용된다는 것이다 이 관계는 포인터 연산을 더 간단하게 만들고 배열과 포인터를 더 다재다능하게 만든다
ex) int a[10];  *a = 7 ( a[0]를 7로 만드는 것과 동일하다)   *(a + 1) = 12; 이렇게 하면 a[1]에 12를 넣는것이다 
일반적으로 a + i는 &a[i]와 동일하고  *(a+i)는 a[i]와 동일하다 배열 참조지정은 포인터 연산으로도 볼 수 있다는 것이다