C언어는 1970년도 벨 연구소에서 만들어져 현재까지 사용되는 프로그래밍 언어이다 
C언어는 이후에 생긴 언어에 많은 영향을 주었다

Chapter1

C언어의 역사 

C언어는 UNIX운영체제의 부산물로 생성되었다 벨 연구소의 켄 톰슨, 데니스 리치등의 C언어를 만들었다 
그 당시에 다른 운영체제들은 어셈블리 언어로 만들어졌는데 어셈블리는 디버그가 힘들고 성능을 향상시키기가 매우 어려웠다
UNIX도 예외는 아니였는데 톰슨은 이러한 문제를 해결하고 UNIX를 더 발전시키기 위해 
높은 레벨의 언어가 필요하다 생각했고 그는 B언어를 디자인했다 하지만 B언어는 PDP-11에 맞지 않다고 생각했고
리치는 더 향상된 버전을 개발했다 처음에는 NEW B언어로 불렸는데 유닉스가 1973년 C언어로 재개발 되었을 때 C언어로 불리게 되었다 
C언어는 70년대에 지속적으로 발전되었다 77~79년이 특히 그런데 이 기간동안 첫 C언어 책이 나오게 되었고 C프로그래머에게
바이블이 되었다 70년대에는 C프로그래머가 비교적 적고 대부분 유닉스 유저였는데 80년대에 들어와서 C컴파일러는
다양한 운영체제에서 사용되게 되였다 특히 IBM PC플랫폼에서 빠르게 성장했다 
C언어가 유명해지고 문제가 찾아왔는데 C컴파일러는 K&R에 의지하였는데 K&R은 언어의 특징이 모호하였고 
이 특징이 자주 다르게 사용되었다 또한 K&R은 이 특징들을 명확히 하는데에 실패했다 그리고 C언어는
K&R이 쓰여진 이후에도 계속적으로 바뀌었다 새로운 특징이 추가되고 오래된 특징은 삭제되었다 
그래서 C언어에 대한 명확한 설명이 필요해졌고 1983년부터 ANSI에서 표준을 만들기 시작하였고 
1989년에 공식적으로 ANSI표준이 승인되었다 이 표준을 C89또는 C90으로 부른다 그리고 이것은 C의 오리지널 버전으로
불리는 K&R과 분리되어진다 
95년에 여러 변화가 있었고 새로운 표준이 필요해졌고 99년에 C99로 불리는 새로운 표준이 승인되었다 


C언어 기반으로 만들어진 언어

C언어는 현대 언어에 거대한 영향을 주었고 아주 많은 언어가 C언어 기반으로 제작되었는데 그 중 중요한 언어는 다음과 같다
- C++  : C언어의 모든 특징을 가지고 있고 클래스와 다른 기능이 추가되었고 객체지향 프로그래밍 언어이다
- JAVA :  C++언어 기반으로 작성되어서 C언어의 많은 특징을 가지고 있다  
- C# : C++과 자바를 기반으로 만든 더 최신 언어이다 
- Perl : 원래는 간단한 스크립트 언어였는데 성장하면서 C언어의 많은 특징을 이식하였다 
C를 배우면 C기반으로 제작된 언어들을 배울때 강력한 통찰력을 주기 때문에 첫 언어로 C를 많이 배운다
그리고 C로 작성된 많은 오래된 코드들이 있어서 C언어를 배우면 이러한 코드를 유지보수 할 수 있다 
C는 여전히 개발에 널리 사용되는 언어이다 특히 메모리가 제한된 환경에서 아주 강력하다 


C언어의 강점과 약점

C의 특징
어느 프로그래밍 언어처럼 C언어도 강점과 약점을 가지고 있다 다음은 C언어의 근본적인 특징들이다
- C언어는 로우 레벨 언어이다  : C는 기계 레벨에 접근을 제공한다 이것은 다른 언어들에게는 감춰진 것이다
또한 컴퓨터에 내장된 명령과 가까워서 프로그램이 아주 빠르다 
- C언어는 작은 언어이다 : C언어는 다른 언어들이 제공하는 특징들이 제한된다 작은 언어의 특징을 가지고 있어서
C언어는 내장된 기본 함수에 의지한다 
- C언어는 자유로운 언어이다 : C언어는 많은 것들을 허용해서 다른 언어들에 비해 자유롭다 또한 다른 언어에서 강제하는
오류확인을 강제하지 않는다 


C의 강점
효율적이다 : C는 어셈블리가 사용될 때 만들어졌기 때문에 아주 빠르고 메모리 양이 제한된다 

이식성이 좋다 : 이식성은 프로그램의 주된 목적은 아니지만 강점중 하나이다 
 프로그램은 컴퓨터에서 동작하는데 PC부터 슈퍼컴퓨터까지 범위가 다양하기 때문에 C언어를 체택하는 경우도 많이 있다
C언어의 컴파일러는 작고 쉽게 쓰여졌다 이러한 특징이 다양한 가능성을 준다 

강력하다 : C는 다양한 데이터 타입과 연산이 있어 아주 작은 코드와 라인으로도 프로그램을 만들 수 있다

유연하다 :  C는 시스템 프로그래밍을 위해 디자인되었지만 이것에 대한 제약은 없다 C는 임베디드부터 상업적 데이터
프로그램까지 모든 분야에 사용된다 

기본 라이브러리가 존재한다 : C의 강점으로 기본 라이브러리가 있는데 이 라이브러리에는 입출력, 문자열 , 저장 할당 등
여러 유용한 수백가지의 함수가 존재한다

유닉스와의 통합 : C는 특히 유닉스와 강력하게 결합된다 

C의 약점
C의 약점은 기계와 가깝다는 C의 강점에 기반하기도 한다 

에러가 생기기 쉽다 : C의 유연성은 에러를 유발하기도 한다 C컴파일러는 다른 언어의 실수를 발견하지 못하는 경우가 많다
이런 점에서 C는 어셈블리와 많이 닮아있다 대부분의 에러는 실행동안 발견하지 못해서 더 많은 문제를 야기한다 
C는 또한 부주의했을 때 눈에 안 띄는 문제를 많이 가지고 있다 

이해하기가 어렵다 :  비록 C는 작은 언어이지만 다양한 방법으로 결합되기 떄문에 타인이 이해하기 어려운 경우가 많다
C의 간결함 때문에도 문제가 방생하는데 간결함을 목적으로 만들어졌기 때문에 읽고 수정하는데 많은 시간이 걸린다 
C의 유연성도 영향을 주는데 천재들이 자기만 알아보게 코드를 작성하면 이해하는게 거의 불가능하다 

수정하기가 어렵다 : C로 작성된 큰 프로그램은 제작될 때 유지보수를 고려하지 않았다면 수정이 매우 어렵다 
현대의 프로그래밍 언어 수정에 용이한 모듈과 클래스를 제공하는데 C언어는 이런 특징이 없다 

C를 효과적으로 사용하기
C를 효과적으로 사용하려면 C의 강점을 사용하고 약점은 숨겨야 한다 

위험을 피하기 : 현대의 컴파일러는 보통 위험을 감지하는데 모든 위험을 감지하지는 못 한다 그래서 위험이 자주발생하는
코드는 주의해서 작성해야한다

소프트웨어 툴을 사용하면 프로그램이 더 신뢰성이 생긴다 :  하나의 예로 lint라는 툴이 있는데 컴파일러보다 에러를
더 잘 잡는 툴이다 또한 디버거가 있는데 C컴파일러가 버그를 잘 잡지 못하기 때문에 이러한 툴을 사용한다면
프로그램의 신뢰성이 더 올라가게 된다 

코드 라이브러리를 이용하라 : C의 강점 중 하나는 많은 다른 사람들이 만든 코드를 라이브러리로 사용할 수 있다는 것이다
잘 맞는 라이브러리를 구하면 에러를 줄이고 효과적으로 프로그램을 만들 수 있다 많은 라이브러리가 있는데
공개되어있는 오픈 소스도 있고 구매해야하는 상업적 소스도 있다

코딩 규약을 따라라 : 코딩 규약은 강제적인 규칙은 아니지만 규약을 따른다면 프로그램 만드는 데 도움이 되고 
다른 사람의 코드를 읽는데 도움이 된다 코딩 규약은 어느 언어에서도 중요하다 

혼란스럽거나 복잡한 코드를 피해라 : C는 프로그램을 만드는 데 다양한 방법이 존재하고 프로그래머는 간결한 방법을
사용하는데에 유횩되는데 가장 짧은 방법은 종종 이해하기가 제일 어려운 방법이 된다 
이해하기 쉽고 복잡하지 않게 코드를 짜야한다 

표준을 지켜라 : 대부분의 C컴파일러는 C89 , C99의 표준이 아닌 라이브러리 함수를 제공한다 
이해안되는 것을 피하기 위해서는 이러한 것들을 꼭 필요하지 않는 한 피해야한다 

chap2

pun.c
#include <stdio.h>

int main(void) {
	printf("To C, or not to C : that is the question.\n");
	return 0;
}
해당 코드에서 "include"부분은 해당 소스는 C의 표준 I/O라이브러리를 불러오는 코드이다 
그리고 "main"함수는 처음 실행하는 부분이고 무조건 있어야 하는 함수이다
printf는 표준 i/o라이브러리에 있는 함수이며 함수 안의 내용을 출력해준다  해당 함수 안의 "\n"은 다음줄로 넘어가게 해주는 코드이다
메인 함수에서 return 0;을 실행하면 프로그램이 종료된다 
그리고 파일 이름은 어느것이던지 상관이 없지만 c 확장자는 컴파일러에게 필요하다 
그리고 해당 파일을 실행하기 위해서는 기계가 실행할 수 있는 파일로 변환해야 한다 변환을 위해서는 세 스텝이 필요하다
1. 전처리  : 프로그램은 처음에 전처리기에 주어진다 전처리기는 그것을 프로그램에 추가하고 변환시킨다 
2.컴파일링 : 변환된 프로그램은 컴파일러에 이동된다 컴파일러는 이것을 기계어로 번역한다(오브젝트 코드 생성) 
3. 링킹 : 마지막 단계이다 링커는 컴파일러가 생성한 오브젝트 코드와 프로그램 실행에 필요한 추가적인 코드를 결합한다 
C언어에서 이 과정은 자동으로 진행된다 
전처리는 보통 컴파일러와 통합되어 실행된다 

컴파일, 링크 등에 필요한 명령은 컴파일러와 OS에 따라 각기 다르다 UNIX에서는 보통 cc명령을 사용한다(gcc컴파일러는 gcc) 
ex) cc pun.c
cc명령에는 다양한 옵션이 있다 대표적으로 -o가 있는데 -o뒤에 이름을 쓰면 해당 이름의 실행파일이 생성된다 
ex) cc -o pun pun.c

통합 개발환경(IDE)
이렇게 컴파일을 하려면 os에서 제공하는 시스템에 들어가서 직접 커멘드를 입력해서 실행해야하는데
IDE를 이용하면 수정,컴파일,링킹,실행,디버그 등을 한꺼번에 할 수 있다 
또한 에러가 있는 라인을 표시하여 오류도 잡을 수 있다 	


C 프로그램은 다음과 같은 형식으로 일반화할 수 있다

directives

int main(void){
	statement
}
C는 다른 언어들과 같이 { 와 } 로 시작과 끝을 나타낸다 그리고 C언어는 3가지 특징이 있는데 
지시문(directive) , 함수 (function) , 내용(statement)이다


지시문 
지시문 C프로그램을 컴파일 하기전에 전처리기에 의해 가장먼저 수정된다 
#include <stdio.h> <- 이것이 가장 기본적인 지시문이다 
이 지시문은 컴파일 하기 전에 기본 I/O라이브러리 정보를 포함시킨다 그리고 C는 이와같은 여러 헤더를 가지는데 각각 헤더는
기본 라이브러리 정보들을 포함한다 C언어는 다른 언어와 달리 내장된 입출력 능력이 없어서 기본 라이브러리의 함수를 대신 사용한다
지시문은 항상 #으로 시작한다 그리고 하나의 라인으로 구성되며 세미콜론은 필요없다 

함수 
함수는 다른 언어에서 절차나 서브루틴과 비슷하다 
함수는 두 카테고리가 있는데 프로그래머가 만든 함수와 C에서 제공되는 라이브러리 함수가 있다 
라이브러리 함수는 컴파일러와 함께 제공된다 
함수는 수학용어이기도 한데 하나 이상의 인수가 주어졌을떄 값을 계산해준다 
C에서 함수는 더 간단한데 연속된 코드가 하나로 묶이고 이름이 주어진다 
그리고 계산된 값이 주어지기도 하고 아니기도 한데 계산된 값은 return 코드로 주어진다 return은 하나만 실행된다 
C에서는 많은 함수가 있지만  main함수는 무조건 있어야한다 main함수는 프로그램이 실행될 때  자동으로 호출되고 
오직 한개의 메인 함수가 존재할 수 있다 메인함수에서 return 은 프로그램의 종료를 의미한다 
int main(void) {
	printf("To C, or not to C : that is the question.\n");
	return 0;
}
이 함수가 있을 떄 int는 해당 함수가 return할 때 어떤 형식으로 리턴을 할지를 나타낸다 void부분은 매개변수인데 
void는 매개변수가 없음을 나타낸다 그리고 메인 함수에서 리턴은 무조건 0을 해야한다 리턴이 없어도 실행은 되지만
대부분 컴파일러는 에러를 출력한다 

코드
코드는 프로그램이 실행하기 위한 명령문이다 예를들어 printf는 해당 함수를 호출하고 해당 함수는 스크린에
문자를 출력해준다 그리고 C언어는 각각 코드의 끝에 세미콜론이 있어야 한다 
컴파일러는 세미콜론을 끝으로 보기 떄문에 코드를 여러라인에 걸쳐서 작성할 수 있다 

문자열 출력
printf함수는 강력한 함수이다 "" 안에 있는 문자들을 출력해준다 
printf함수는 끝난 후에 자동으로 다음 줄로 출력을 넘기지 않는다 하나의 라인으로 사용을 하려면 \n을 포함시켜야한다
\n을 쓰면 현재 줄이 끝나고 다음줄로 넘어간다 또한 \n은 한 printf함수에서 여러번 사용이 가능하다 

주석
c프로그램에서 문서화는 아주 중요하다 모든 프로그램은 프로그램 이름, 작성일, 저자, 목적 등의 정보가 필요하다 
C에서는 /*로 시작하고 */로 끝내는  심볼을 이용해서 주석을 달 수 있다  
ex) /* this is comment */
주석은 프로그램 어디든지 작성할 수 있다 그리고 /* */ 심볼을 이용해서 주석을 달면 컴파일러는 */가 나올때까지 읽기
떄문에 여러줄에 걸처서 작성을 할 수도 있다 주석을 여러줄로 할 때 /* */만 사용하면 읽기가 어려울 수 있어서 
*로 박스를 만들어서 가독성을 높이는 방법도 있다 프로그래머는 대부분 
/*
* 내용
*/
이런식으로 가상에 별을 넣어서 주석을 만든다 그리고 주석을 끝맺지 않고 코드를 작성하면 그 코드도 주석이 된다 
C99부터는 다른 타입의 주석을 제공하는데 //로 주석을 다는것이다 
ex) // This is comment 
이 주석은 줄이 끝나면 자동으로 종료된다 여러줄에 주석을 달려면 /* */방법을 사용하거나 줄마다 //를 달아야한다 
//를 사용하면 종료를 명시할 필요가 없다는 장점이 있다 	

변수와 할당 
대부분의 프로그램을 출력을 하기전에 미리 계산을 시킨다 그리고 이것을 하기 위해서는 데이터를 일시적으로 저장할 곳이 필요하다
대부분 프로그래밍 언어에서는 변수를 이러한 저장장소로 사용한다 

타입
모든 변수는 타입을 가진다 타입은 어떤 종류의 데이터를 저장할지 명시한다 
타입은 저장할 수 있는 최소 숫자와 최대 숫자의 범위를 가진다 
int는 최대 2147483647의 범위를 가진다 
float는 더큰 숫자를 가질 수 있고 소수점도 표현이 가능하다 하지만 float는 int보다 느리다는 단점이 있다 
그리고 많은 경우에서 float는 근사치를 가지는 경우가 많다 예를들어 0.1를 저장했는데 나중에 볼떄는
0.0999999999987로 나오는 경우가 있다 

선언
변수를 사용하기 위해서는 반드시 선언을 해야한다 선언을 하기 위해서는 먼저 변수의 타입을 입력한다 
그리고 나서 변수의 이름을 입력한다 
ex) int height; float profit; 인트형으로 height변수 선언, float형으로 profit변수 선언
한번에 여러 변수도 선언이 가능하다 ( int height, length, width , volume;)
그리고 변수를 선언하는 부분과 코드부분을 빈 줄로 구분하는것이 가독성에 좋다 
변수를 코드 위쪽에 선언을 하는것이 맞지만 C99부터는 이것이 의무는 아니다 

할당
변수는 값을 할당할 수 있는데 다음과 같이 한다
ex) height = 8; length = 12; width = 10;
할당된 값은 바뀌기 전까지 지속된다 그리고 값 할당은 반드시 선언 이후에 해야한다 
그리고 float값을 할당할때는 보통 소수점을 사용한다 
ex) float profit = 2150.48;
float변수에 지속적으로 소수점을 포함하려면 끝에 f를 붙이면 좋다 (float profit = 2150.48f;)
f를 안붙이면 컴파일려가 경고를 출력한다 
한번 할당된 변수는 다른 변수 계산에 사용할 수 있다
ex) height = 8;  length = 12; width = 10; volume = height * length * width;(여기서 *는 곱하기 연산을 의미한다)

변수의 값 출력
printf함수를 이용하여 변수의 값을 출력할 수 있다 
ex)printf("Height : %d\n", height); 여기서 %d는 height값으로 대체한다 
%d는 오직 int값만 출력이 가능하다  float타입 값을 출력하려면 %f로 사용해야한다 float는 소수점 6자리까지 출력된다
소수점 자리를 설정을 하고 싶다면 다음과 같이 사용한다
ex) printf("profit : %.2f\n" , profit); 이렇게 하면 소수점 2자리수까지 출력된다 
printf에서 사용할 수 있는 변수의 개수에는 제한이 없다  
printf함수 내에서 연산해서 값을 출력할 수도 있다
ex) printf("%d\n" , height * length * width);

/는 나누기 연산을 의미하는데 나눠지는 값이 정수면 연산 결과는 소수점을 버린 정수가 나온다 

초기값 설정
어떤 변수는 자동으로 0으로 초기화 된다 그러나 대부분의 경우는 그렇지 않다 
그래서 항상 변수를 선언할 떄 값을 초기화 해주는 것이 좋다 
ex) int height = 8;  
변수를 한꺼번에 초기화는 할 수 없다
ex) int height , length , width = 10; 이렇게 하면 width만 10으로 초기화되고 나머지는 초기화되지않는다 


입력받기
scanf함수를 통해 사용자에게 값을 입력받을 수 있다 scanf는 printf와 대응되는 함수여서 구성이 비슷하다 사용은 다음과 같이 한다
ex) scanf("%d" , &i);  int값을 받아와서 i에 넣는다
%d는 printf에서와 마찬가지로 int형 값을 받는다는것을 의미한다 &i는 i의 주소를 나타낸다 
i의 주소에 int형 값을 넣는다는 것을 의미한다 floaat형은 다음과 같이 사용한다
ex) scnaf("%f", &x);  float값을 받아서 x에 넣는다 

매크로 상수 선언
매크로 상수는 선언하면 그 값은 바꿀 수 없게된다 선언은 다음과 같이 한다
#define INCHES_PER_POUND 166
#define은#include처럼 전처리기쪽에서 수행해서 세미콜론을 사용하지 않고 줄이 끝나면 명령이 끝난다 
컴파일할때 전처리기는 각각의 매크로 값을 코드에서 치환한다
ex) weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND); 여기서 매크로 상수 부분이 166으로 변한다
매크로 상수는 대문자를 사용하고 문장 사이에는_를 넣는다 

식별자
식별자는 변수, 함수, 매크로 등에 이름을 붙인것을 말한다 식별자는 알파벳, 숫자, 그리고 _ 가 들어갈 수 있다 그러나
반드시 처음은 알파벳 또는 _ 가 들어가야 한다 
ex) times10 , goet_next_char  _done 옳은 식별자 
ex) 10time  get-next-char  옳지 않은 식별자( 숫자가 맨 앞, 들어올 수 없는 문자가 들어감)
그리고 C는 대문자와 소문자가 구별이 된다 그래서 아래는 모두 다른 식별자이다
ex) job joB jOb jOB Job JoB JOB JoB
C프로그래머가 식별자 이름을 지을때 관례가 있는데 하나는 _로 구분을 하는것이다
ex) symbol_table current_page name_and_address(스네이크 표기법)
그리고 하나는 대문자로 구분을 하는 것이다
ex) symbolTable currentPage nameAndAddress(카멜표기법)
키워드는 식별자의 이름으로 사용할 수 없다 다음은 C에서 사용하는 키워드들인데 식별자로 사용할 수 없다

키워드
auto	enum	restrict(C99부터)	unsingned	break
extern	return	void	case	float	short	volatile
char	for	signed	while	const	goto	sizeof
_Bool(C99부터)	continue	if	static	_Complex(C99부터)
default	inline(C99부터)	struct	_Imaginary(C99부터)    do
int	switch	double	long	typedef	else	register	union


C프로그램 배치
C프로그램은 연속적인 토큰으로 구성되는데 식별자나 키워드는 그 의미를 바꿀 수 없다 
+, - 나 ; 같은 printf함수를 호출하는 코드가 있을 떄 항목은 7개로 나눌 수 있다
ex) printf - 1번째토큰  ( - 2번째 토큰  "Height : %d\n" - 3번쨰 토큰   , - 4번째 토큰  height - 5번쨰 토큰 ) -6번쨰 토큰 ; - 7번째 토큰
여기서 1,5번은 식별자이고 3번은 문자열 2,4,6,7은 구두점에 해당된다 토큰들 사이의 공간은 대부분의 경우에는 
크게 의미가 없다 하지만 가독성을 위해서는 적절한 공간이 필요하다 
토큰 사이의 스페이스,  탭, 줄바꿈 등을 사용하는 규칙은 프로그램 배치에 아주 중요하다 
1. 코드를 한줄로 하기가 너무 길어 한줄로 하기 어려우면 여러 라인으로 나눌 수 있다
2. 토큰 사이의 공간은 가독성에 좋기 때문에 각각 연산 사이에는 공간을 두는것이 좋다 
3. 들여쓰기는 블럭 공간을 구성하기에 좋다 
4. 비어있는 줄은 프로그램 구조를 보기 쉽게 만들어준다 
토큰 내에서 공간을 주면 프로그램 오류를 유발할 수 있다 그리고 문자열 사이에 줄바꿈을 하면 오류가 생긴다
  

GCC컴파일러  
GCC컴파일러는 GNU 에서 만든 C언어 컴파일러이다 GCC컴파일러를 사용하면 여러 옵션을 사용하여 잠재적 문제가 발생하는 부분 등 철처하게
프로그램을 체크할 수 있다 대표적인 옵션은 다음과 같다
-WALL : 잠재적 에러에 대한 위험 메시지를 출력한다 -O옵션과 같이 사용하면 효과가 좋다
-W :  -Wall옵션이 생성한 것에 더해서 추가적인 위험 메시지를 출력하다 
-pedantic  :  C표준이 아닌 코드에 대해 위험을 감지한다
-ansi : GCC표준을 켜지 않아서 원래 안되는 몇몇 특징을 가능하게 하다 
-std=c89 , -std=c99 : 버전을 명시해서 C컴파일러가 프로그램에서 사용할 수 있게 한다 
이러한 옵션들은 조합해서 사용된다
ex) gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c

main함수에서 리턴 부분에 return 0와 exit(0)은 동일한 기능을 한다 
main함수에서 리턴 부분은 의무는 아니고 C89부터는 없어도 종료는 된다 C99부터는
return부분이 없으면 프로그램은 자동으로 0을 리턴한다 

주석 부분을 종료하지 않으면 컴파일이 되지 않는다 주석을 종료하지 않는 부분이 프로그램을 이상하게 만들기 때문이다
주석을 종료하지 않으면 그 부분이 강조되서 그 부분을 고치면 된다
/* */이 주석안에 /* */주석을 넣으면 오류가 발생한다 */이 부분이 종료가 되기 때문이다 

float값 뒤에f를 붙이지 않으면 double타입으로 인식을 하기 때문에 범위가 훨신 커지게 된다 

C89부터 식별자 이름의 길이에는 제한이 없다 하지만 컴파일러는 처음 31자만 인식을 하기 때문에 처음 31(C99부터는 63자)자가 같으면
같은 식별자로 인식을 한다 그리고 오래된 linker를 하용하면 처음 6자리만 인식을 하게 된다 (대부분 컴파일러는 이부분을 무시해도된다)

chap3  

printf함수
printf함수는 문자를 화면에 보여주도록 디자인되었다 printf함수는 반드시 서식 문자열이 있어야 한다 
그리고 서식 문자열에 변수 출력 형태를 넣으면 넣으면 뒤에 변수를 넣어야한다
ex)printf(string, expr1, expr2,...);
값에는 변수, 상수 ,복잡한 표현등이 들어갈 수 있고 숫자에는 제한이 없다 
서식 문자열에는 평범한 문자와 %로 시작하는 전환되는 문자가 올 수 있다 이것은 뒤에 넣는 값으로 대체가된다
또한 %뒤에오는 형식에 맞는 값이 와야한다 
C컴파일러는 printf 서식 문자열에 있는 %로 시작하는 문자의 개수와 뒤에 오는 값의 개수 숫자를 체크하지 않는다
%를 1개 쓰고 뒤에 2개가 왔을 떄 뒤에것은 출력이 되지 않고 %을 2개 쓰고 뒤에 1개가 왔을 떄는 의미없는 값이 출력된다 
타입에 맞지 않는 값이 와도 의미없는 값이 출력된다 

변환지시어 
변환지시어는 프로그래머에서 컨트롤할 수 있는 강력한 힘을 주지만 복잡하고 읽기가 힘들다 
%뒤에는 많은 옵션이 있다 
ex) %m.pX    %-m.pX 이런식으로도 올 수 있는데 m과 p는 숫자로 들어가고 옵션이다 X는 문자형식이 들어가고 필수로 들어가야한다   
ex) %10.2f  여기서 m이 10이고 p가 2 X가 f가 된다  %.2f가오면 m은 없는거고 p가 2 X가 f이다
m은 최소 길이를 나타낸다 10이 들어가면 최소 10자리가 확보가 되는 것이다 그리고 입력한 숫자가 값이 자리보다 크다면
오른쪽부터 채워진다 
ex) %4d  , 123 이렇게 했을 때 0123  ( 0은 빈칸) 이렇게 채워진다 
자리수가 입력한 숫자보다 크면 자동으로 확장된다 그리고 앞에 -를 붙이면 오른쪽부터 채워지는 것이 아니라 왼쪽부터 채워지게 된다
ex) %-4d , 123 이렇게 입력했을 때 1230 (0은 빈칸)이렇게 채워진다 
p는 X가 소수점 형식일 떄 소수점 몇자리까지 오는지를 입력하는 곳이다 
ex) %.2f , 12.111111111이렇게 온다면  12.11이렇게 출력이 된다 
X는 전환되는 형식을 나타낸다 자주 사용하는 형식은 다음과 같다
-d  : int형식을 10진수 형식으로 출력한다 
-e : float 형식의 숫자를 지수 형식으로 출력한다 p는 소수점 뒤에 얼마나 많은 숫자를 표시할지를 나타낸다 기본값은 6이다 0이면 
소수점 자리가 표시되지 않는다 
-f : float 형식을 부동 수수점 형식으로 출력한다 p부분은 e와 같다
-g : float형식을 부동소수점 또는 지수형식으로 출력하는데 숫자의 크기에 따라 달라진다 숫자의 범위가 작으면 f 크면e형식으로 출력

확장열
\n은 서식 문자열에서 자주 사용되는 코드의다 확장열이라 불리는데 출력되지 않고 줄바꿈 등 특별한 기능을 수행한다 
대표적인 확장열은 다음과 같다
Alert(bell) : \a  경보가 울린다 
Backspace : \b    뒤로 한칸 이동한다  
New line : \n   줄바꿈을 한다 
Horizontal tab : \t    수평탭 간격을 띄운다 
"출력   : \"   큰따옴표 출력 
\출력 : \\    \출력 
%출력 : %% 

scanf함수
scanf함수는 특정 형식을 불러오는 함수이다 서식 문자열에는 일반 문자와 변환 지시어가 오는데 
변환 지시어의 사용 방식은 printf와 동일하다 대부분은  변환지시어만 사용한다 
scanf도 printf처럼 부주의 했을 때 함정에 빠질 수 있는데 변환 지시어와 뒤의 값 개수가 같아야 하고
적절한 값이 와야한다 또한 &를 사용해야한다 &는 변수의 주소를 의미한다 
&를 사용하지 않으면 주소에 들어있는 값의 주소에 값을 넣기 때문에 오류가 발생한다 
scanf는 강력하지만 아주 힘든 읽는 방법이다 

scanf가 동작하는 방식
printf와 마찬가지로 scanf는 서식문자열을 다룬다 함수가 호출되면 문자열의 왼쪽부터 정보를 읽는다 
그리고 빈칸을 스킵하고 적절한 문자열의 위치를 찾아낸다 그리고 적절하지 않은 문자가 올때까지 입력을 읽는다
그리고 남은 서식문자열이 있으면 계속 진행한다 읽는데에 실패하면 남은 서식문자열이 있어도 즉시 반환한다 
scanf는 공백을 무시한다(스페이스, 세로또는 가로 탭 , 줄넘김 등) 결과적으로 한줄에 여러개 또는 여러 라인으로
값을 받아올 수 있다
ex) scanf("%d%d%f%f", &i ,&j ,&x , &y); scanf가 이렇게 되어있을 때
   1  
-20     .3  
   -4.0e3  이런 입력이 와도 공백은 무시되기 떄문에 정상적으로 읽는다
int를 읽을 때 처음으로 보이는 숫자를 찾고 숫자가 아닐떄까지 읽는다 
입력을 지수형식으로 할 수도 있다 

서식 문자열의 평범한 문자
빈 문자 : scanf에서 공백을 만나면 공백이 아닌 문자가 올때까지 읽는다 그래서 한개 이상 공백은 의미는 없다 
다른 문자 : 서식 문자열에서 공백이 아닌 문자를 읽으면 scanf는 입력받은 다음 문자열과 비교한다
만약 같으면 그 입력은 버려진다 그리고 서식 문자열은 계속 이런 과정을 반복한다 
두 문자가 같지 않으면 scanf는 입력에 놓는다 
ex) 서식문자열 - "%d/%d"일떄 입력으로 05/096을 입력하면 
scanf는 처음 공백을 스킵하고 %d로 5를 읽는다 그리고 /는 서식 문자열에 있는 /떄문에 스킵되고 두번쨰 %d로 96을 읽는다
만약 050/096을 입력했다면 5는 정상적으로 들어오는데 /이 와야하는곳에 공백이 와서 두번째 %d로 /096을 읽어버리게 된다
이 입력이 정상적으로 되게 하려면 "%d /%d" 서식문자열을 이렇게 해야한다 

printf와 scanf의 혼란
printf와 scanf함수는 상당히 유사해보이지만 상당한 차이가 있다 차이점을 무시하고 프로그램을 짜면 매우 위험하다
예를들어 printf의 변수가 오는 곳에 &변수명 이렇게 하면 잘못된 코드가 된다 반대로 scanf에 &를 넣지 않으면 잘못된 코드가 된다 
그리고 scanf를 scanf("%d, %d", &i, &j); 이렇게 했을 때 처음 숫자 뒤에 콤마가 아닌 공백이 오면 j를 읽지않고 종료가 된다
그리고 scanf에 확장열을 사용하면 동작은 하지만 좋지 않은 코드가 된다 

%d대신에 %i를 사용할 수도 있는데 %i를 사용하면 8진수 또는 16진수가 올 수가 있다 
숫자앞에 0이 있으면 8진수 0x가 있으면 16진수로 판단한다 


chap4  (Expressions)

가장 심플한 표현은 상수와 변수이다 변수는 계산된 값을 나타낸다 그리고 상수는 변하지 않는 값을 나타낸다 
더 복잡하게 가면 연산자와 피연산자가 있다 
ex) a + (b *c)의 식이 있을때 +는 연산자고  a,b,c는 피연산자다 
C언어에서는 다른 언어에서도 찾을 수 있는 기본적인 연산자를 제공한다 
-산술 연산자 (+ / 등등)
-관계 연산자 (값을 비교하는)
- 논리 연산자
이것들 말고도 연산자가 다수 존재한다 다른 연산자들도 알면 좋지만 이 연산자들을 능숙히 다루는 것이 우선이다 

산술 연산자 
산술 연산자에서 더하기, 뺴기 , 곱하기 , 나누기가 있다 

단항연산자 		이항연산자
+(단항이 +인지)		+(더하기)        *(곱하기) 
- (단항이 -인지)		-(뺴기) 	        /(나누기)
				       %(나머지)
단항연산자의 예는 다음과 같다
ex) +1  , -i    +단항연산자는 의미는 없다 -는 음수를 나타낸다
그리고 이항연산자는 %빼고는 친숙한 연산자들이다 %연산자는 두 수를 나누고 몫이 아닌 나머지를 계산한다 
int형과 float형을 피연산자로 연산을 하면 결과는 float가 나온다 
int형끼리 /연산을 했을 떄 정수형으로 결과가 나와서 소수점은 버려진다 ex) 1/2 = 0
%연산자는 정수형 피연산자가 필요하다 없으면 컴파일이 안된다 
/연산 , % 연산에서 오른쪽 피연산자에 0을 넣으면 아무 행동도 하지 않게된다
C89까지 %와 /연산은 값이 정확하지 않은 나쁜 연산이였는데 C99부터는 이것이 해결되었다 

연산자 결합과 우선순위
연산자가 다중으로 사용되면 어떤식으로 결합되는지 이해하기가 어렵다 그래서 C언어에는 연산자마다 우선순위가 존재한다

가장우선   +   - (단항)
	*      %
가장안우선     + -  (이항)
같은 라인에 있는것들은 같은 우선순위를 가진다 
이런 우선순위가 있어서 연산이 많아도 어떤 연산부터 진행할지 알 수 있다
그리고 같은 우선순위의 연산자가 많이 있다면 이항 연산은 왼쪽부터 우선적으로 결합되어 연산이 진행된다
ex) i - j - k   =  (i -  j) - k
단항 연산은 오른쪽부터 우선으로 진행된다
ex)   - + i    =   - (+i)


지정 연산자 
계산을 하면 계산 한 것을 나중에 사용하기 위해 집어넣은 공간이 필요하다  C는 =(지정연산자)를 통해 이 역할을 수행하는데
지정연산을 사용하면 이미 저장되어있는 값이랑 상관없이 값을 갱신해준다 

간단한 지정
v = e  의 방식으로 지정 연산자를 사용하면 e에있는 값이 복사되어서 v변수에 들어간다 
ex) i = 5; j = i;    k = 10 * i + j;
만약 v와 e가 같은 타입이 아니라면 e의 타입이 v의 타입으로 변환되어서 들어간다 
ex)int  i = 72.99f  (i에는 72가 들어간다)     float f = 136(f에는 136.0이 들어간다)
지정연산자는 연쇠적으로도 사용할 수 있다 
ex) i = j = k = 0  지정 연산자는 오른쪽부터 진행하기 때문에 0이 k, j, i에 들어간다 
지정 연산자는 공간의 제약이 없어서 다양한 방법으로 사용이 가능하다 
ex) i = 1;  k = 1 + ( j = i)     이렇게 하면 j에는 1이 들어가고 1+1이여서 k에 2가들어간다
			
Lvalues
연산은 변수 상수등 피연산자와 함게 사용한다 하지만 지정연산자는 좌측의 피연산자는 반드시
메모리에저장할 수 있어야 한다 또한 좌측의 피연산자에는 다른 식이 올 수 없다 
ex) 12 = i;   i + j = 0;    -i = j  이러한 연산은 잘못된 연산이 된다 
이러한 연산이 오면 컴파일러가 오류를 알린다

복합대입연산자(compound assinment)
지정연산을 사용할 떄 오래된 값을 사용한 연산을 통해 새로운 값을 만드는 경우가 많다 
EX)  I = I + 2;
C에서 복합대입연산자를 사용하면 코드를 짧게 쓸 수 있다 
ex) i +=2;   위에 있는 i = i + 2;와 동일하다 
+=이외에도  -= %= /= *=도 사용이 가능하다 
- v += e   :  v와 e를 더한 값을 v에 넣는다
- v -= e   : v에서 e를 뺀 값을 v에 넣는다
- v *= e  :   v와 e를 곱한값을 v에 넣는다 
- v /= e :   v에서 e를 나눈값을 v에 넣는다
- v %= e  : v에서 e를 나눈 나머지를 v에 넣는다 
복합대입연산자는 풀어서 연산한것과 완전히 동일하지는 않는다 드문 경츠우로 
v += e 와   v = v + e는 다른 결과가 나온다 
복합대입연산자를 연쇄적으로 사용하면 다음과 같이 동작한다
ex)  i += j += k;    는     i += (j += k);이렇게 동작한다 

증감연산자
변수에 1을 더하고 빼는 연산은 아주 자주 사용하는데 이것을 간단히 사용하는 방법이 증감연산자를 사용하는것이다
++ 와 -- 를 사용하는것인데 해당 연산을 변수와 함께 사용하면 변수의 값을 1 증가 또는 감소시킬 수 있다
주의할 점은 증감연산자의 위치이다 변수 앞에 쓰냐 뒤에 쓰냐에 따라 값이 달라질 수 있다
ex) i = 1  printf("%d",  ++i);   printf("%d", i); 이렇게 앞에 증감연산자를 쓰면 첫printf때 값이 증가돼서 2가 출력된다(값을 증가시키고 나머지 연산 실행)
ex) i = 1 printf("%d", i++); printf("%d",i)이렇게 증감연산자를 뒤에 쓰면 첫 printf때는 값이 1 출력이 된다 하지만 
두 번쨰 printf에는 2가 출력된다 뒤에 증감연산자를 사용하면 값을 증가시키지 않고 나머지 연산을 수행하고 수행 수 값을 증가시킨다
앞에 증감연산자를 쓰면 즉시 값을 증가시키고 뒤에 증감연산자를 쓰면 오래된 값을 사용하고나서 값을 증가시킨다

수식 순서

순위 	이름		심볼		방향
1	증감(후)		++		왼쪽에서 오른쪽
	감산(후)		--		왼쪽에서 오른쪽
2 	증감(선)		++		오른쪽에서 왼쪽
	감산(선)		--		오른쪽에서 왼쪽
	단항 +		+		오른쪽에서 왼쪽
	단항 - 		- 		오른쪽에서 왼쪽
3	곱하기 나누기	*, /,  %		왼쪽에서 오른쪽
4	더하기빼기	+ , -		왼쪽에서 오른쪽
5	할당연산		=, +=, /=		오른쪽에서 왼쪽
이 표는 연산사이의 순서와 연산 방향을 나타낸다 

하위표현식 순서
하위표현식의 순서를 나타내는 규칙은 따로 없고 어느 순서로 해도 대체로 맞지만 아닐때가 있다 
c = (b = a + 2 ) - ( a = 1); 이런 식이 있을 때 C는 어떤일이 일어날지 말해주지 않는다 
대부분의 컴파일러는 6또는 2를 출력하는데 어떤 식이 먼저 실행되느냐에 따라 달라진다 
이런 것을 막기 위해서 하위표현식의 순서를 피하는 것이 좋다 
ex) a = 5;  b = a + 2;  a = 1; c = b- a;
가감산 연산을 동시에 포함하는 연산에서도 이런 문제가 발생한다 
ex) i = 2; j = i  * i++; 보통 j의 값으로 4를 예상하지만 4가 올수도 있고 6이 올수도있다

표현식 문(Expression Statement)
C에서는 어떤 표현식이든 문이 될 수 있다  ++i;의 문이 실행될 때 i는 값이 증가하고 i에 들어간다
하지만 ++i는 더큰 표현식이 아니다 이 값은 다음 문이 실행될때 버려진다(i값은 변한다)
ex) i = 1;  i--;  i * j - 1;   이 3가지 문이 있을 때 마지막 문은 아무런 영향을 끼치지 않는다 

%연산은 정수끼리 연산만 가능하지만 fmod함수를 사용하면 실수도 가능하다 
v += e 와 v = v + e의 차이점은 v+=e는 딱 한번만 계산하지만 v = v + e 는 두번 계산한다는 점에서 차이가 있다
a[i++] +=2;      a[i++] = a[i++] + 2; 이 두 식이 있다고 했을 때 끝나고 난 후의 i값을 다르게 된다
현대의 C에서는 -- 또는 ++ 연산이 더 빠르지 않지만 간편하고 편해서 자주 사용한다
++또는 -- 연산은 float에서도 사용이 가능하다 
후위 가감산 연산은 sequence point라는 개념이 있는데 이전 sequence point와 다음 sequence point사이에서 일어난다

chap5  selection Statement(조건문)

프로그램을 짜다보면 retrun문을 실행할지 다른 표현식을 사용할지에 대해 직면한다 대부분의 경우에는
실행 순서에 미치는 영향에 따라 3가지 카테고리중에 사용한다 
조건문(selection statement) : if문과 switch문이 있고 선택 가능한 것들 중에 특정 문을 실행한다 
반복문(iteration statement) : while문과 for문이 있고 반복을 지원한다
분기문(jump statement) :  break, continue , goto 문이 있고 프로그램의 다른 위치로 이동을 시켜준다 

논리 표현식(logical expressions)
많은 C문에서 if문을 포함하는데 반드시 true또는 false값이 있어야한다 
i< j가 있을 때 해당 식은 Boolean또는 논리 타입(0-false  1-true)을 반환한다 

관계연산자(Relational Operators)
C의 관계연산자는 수학에서의 < > 등 관계연산자와 일치한다 결과값으로 0또는 1를 생산한다는 것을 뺴고
ex) 10 < 11은 1을 생산하고   11< 10 은 0을 생산한다
관계연산자는 다음과 같다
심볼		뜻
<		더 작다
>		더 크다
<=		더 작거나 같다
>= 		더 크거나 같다
관계연산자는 정수형 실수형을 동시에 사용할 수 있다
관계연산자의 우선순위는 계산 연산자들보다 순위가 낮다
ex) i + j < k -1   =   (i + j) < ( k -1 )
관계 연산자는 왼쪽부터 실행한다
ex) i < j < k = (i < j)  < k    이 식은 변수들의 크기를 비교하지 않는데 처음 연산으로 1 또는 0이 나오기 때문이다

동등 연산자(Equality Operators)
동등연산자는 다음과 같다
심볼		뜻
==		같다
!= 		같지 않다
관계 연산과 같이 동등 연산자도 왼쪽부터 실행하고 0 또는 1을 결과값으로 가진다 하지만 
동등연산자는 관계연산자보다 우선순위가 낮다
ex) i < j == j < k     =    (i < j) ==  (j < k)

논리 연산자(Logical Operators)
복잡한 논리 표현식을 논리 연산자로 간단히 할 수 있다  논리 연산자는 다음과 같다
심볼		뜻
!		논리 부정(단항연산자)
&&		논리곱(이항연산자)
||		논리합(이항연산자)
논리 연산자의 결과로 0 또는 1의 값이 나온다 그리고 피연산자의 값도 0인지 아닌지를 판단한다 
ex) !expr 의 값이 1이면 expr은 0이다   ,   expr1 && expr2의 값이 1이면 expr1, expr2둘다 0이 아니다
expr1 || expr2의 값이 1이면 둘중 하나는 0이 아니다
논리 연산자를 실행할 때 왼쪽 피연산자부터 계산하고 오른쪽 피연산자를 계산한다 
왼쪽 피연산자를 계산했을 때 이미 결과가 나오면 오른쪽 피연산자는 계산하지 않는다
ex) (i != 0 ) &&  (j / i > 0) 의 연산이 있을 떄 i != 0의 결과로 0이 나오면 오른쪽 피연산자의 값이 어떻든 0이 나오기 떄문에 계산하지 않는다
논리 연산에서 이것과 관련해서 주의해야하는 것이 있는데
ex) i > 0  && ++j > 0 이 식이 있을 때 왼쪽 피연산자의 결과로 0이 나오면 오른쪽은 계산을 하지 않기 떄문에 j는 증가하지 않는다 
!연산은 단항 + - 와 같은 우선순위를 가지며 오른쪽부터 실행하고    && 와 ||는 관계연산, 동등연산자보다 우선순위가
낮고 왼쪽부터 실행한다 

if문
if문은 표현식의 값에 따라  두 대안을 골라서 실행한다 if문은 다음과 같은 형태를 가진다
ex) if (expression)  statement
expression은 무조건 있어야 한다 expression값이 0이 아니면 statement를 실행한다
ex) if( line_num == MAX_LINE) line_num = 0;  여기서 line_num== MAX_LINE의 값이 0이 아니면 line_num = 0;을 실행한다 
지정연산자와 동등연산자를 혼동해서는 안된다 지정연산자를 사용하면 항상 0으로 판단한다

복합문
if문에 statement를 여러 개 넣고 싶다면 statement를  중괄호( {와 } ) 로 감싸면 된다 
이렇게 중괄호로 감쌀 때 보통 statement는 여러줄에 걸쳐서 사용을 한다
ex) 
{
  line_num = 0;
  page_num++;
}

else절
if문은 else절과 함께 사용이 가능하다 사용 형태는 다음과 같다
ex) if(expression) statement  else  statement
여기서 else에 있는 문은 표현식의 값이 0일떄 실행된다 
ex) 보통 if, else문은 다음과 같이 사용한다
if(i > j)
  max = i; 
else 
  max = j;
짧게 사용하기 위해서 다음과 같이 작성하기도 한다
if(i>j) max = i;
else max = j;

if문 내부에 if를 쓰는 등 내부문에는 제약이 없다 
ex) if(i > j){
       if(i > k){
	max = i;
       }else {
	max = k;
      }
   }else{
     if(j > k){
	max = j;
     }else{
    	max = k;
     }
}

다단계 if문( cascade if statement)
다단계 if문은 다음과 같이 사용한다
if(expression)
  statement
else if(expression)
  statement
....
else
  statement
여기서 마지막 else문은 필수는 아니다 
다단if문을 사용할 떄 else가 어떤 if문을 사용해야 하는지 모호한 문제가 발생할 수 있는데
ex) if (y != 0 )  if( x != 0 ) result = x/y;  else printf();
C언어에서는 esle문은 가장 가까운 if문을 따른다 더 명확히 하기 위해 중괄호를 사용하면 알기가 쉬워진다

조건 표현식(Conditional Expression)
C의 if문은 조건에 따라 1개나 2개의 액션을 취하는데 C는 이런 1개나 2개의 값에 의존하는 조건식을 제공한다
조건표현식은 다음과 같이 사용한다
ex) expr1 ? expr2 : expr3  expr들은 어느 타입의 표현식도 가능하다 
이 표현식을 사용하려면 피연산자가 3개가 필요하기 때문에 삼항연산자라고도 부른다 
expr의 결과가 0이 아니면 expr2 0이면 expr3을 반환한다 
우선순위는 대입 연산자보다는 높지만 다른 연산보다는 낮다

C89에서 boolean값
오랜시간동안 C는 적절한 Boolean타입이 없었다 그래서 프로그래머들은 참과 거짓을 표현하는 다양한 방법을 
사용하였다 
ex) int flag; flag = 0;  flag = 1;    또는 #define TRUE 1  #define FALSE 0
여기서 더 나아가 타입을 만들어서 사용하였다
ex) #define BOOL int   BOOL flag;

C99에서 boolean값
오랜기간동안 C에서 boolean자료형은 없었는데 C99부터 _Bool 타입을 제공하였다 
ex) _Bool flag;
_Bool은 int타입이지만 오직 0과 1만 올 수있다 다른값을 넣어도 1으로 변환된다
C99에서는 또한 <stdbool.h>라는 새로운 헤더를 제공한다 이 헤더는 매크로 bool등을 제공하는데
이것을 사용하면 쉽게 bool변수를 사용할 수 있다
ex) bool flag  (_Bool과 동일)   flag = false;  flag =true;

switch문
다중 if문을 사용하여 구현하는 것을 switch문으로 대체해서 구현이 가능하다 
ex) 왼쪽 다중 if문을 사용한 것을 switch문을 사용하면 아래와 같다 
if(grage == 4){           switch(grade{
  print();			case 4 :  print; break;
 }else if(grade == 3){   	case 3 : print; break;
  print();			case 2 : print; break;
}else if(grade == 2){ 	case 1 : print; break;
}else if(grade == 1){ 	case 0 : print; break;
}else if(grade == 0 ){ 	default: print; break;
}else{ print }		}
해당 switch문이 실행되면 grade가 4,3,2,1,0인지 체크해서 맞으면 case내부의 문을 실행하고 break를 만나면 switch가 종료된다
grade가 맞는 값이 없으면 default의 문이실행된다 복잡한 경우에서 switch문은 다중 if문보다 읽기가 쉽고 더 빠르다 
일반적은 switch문은 다음과 같이 구성된다
switch(expression){
  case constant-expression : statement
...
  case constant-expression : statement
  default statement }
switch에서 표현식은 반드시 정수가 와야한다 char도 C에서는 정수로 표현되기 때문에 사용이 가능하다 float나 string은 안된다
case로 시작하는 case-label이 있는데 constant-expression은 일반표현식이지만 변수나 함수등이 올 수 없다 반드시 정수나 문자가 와야한다
case label뒤에는 문이 오는데 문의 숫자는 제한이 없고 중괄호도 필요없다 보통 마지막 문에는 break를 사용하는데
필수가 아니다 break가 없으면 다음 case-label이 실행된다 
case label을 복사하는것은 허용이 안되며 순서는 상관이 없다 default도 마지막에 올 필요는 없다
여러개의 case label이 같은 문을 사용할 수도 있다
ex) switch (grade) { case 4 : case 3 : case 2 : case 1 : printf() break; case 0 : printf() break; default print(); break;
위와 같이 사용하면 4 ,3 ,2 1일떄 동일한 문을 사용한다 범위는 지정이 불가하다 
default를 사용하는 것도 선택이기 때문에 무조건 넣을 필요는 없다 

break문의 역할 
switch에서 break문을 사용하면 switch다음 구문으로 이동을 한다 
break가 필요한 이유는 break를 사용하면 계산된 곳으로 점프를 하기 떄문이다 switch문에서 break문이없다면
expression의 case label부터 마지막 case label까지 모두 실행된다 
의도적으로 break를 안쓰는 경우는 드물기 때문에 안쓰는 경우에는 주석을 다는것이 좋다 마지막 case label은
break는 필요하지 않지만 나중에 추가될 수도 있기 때문에 break를 쓰는 것이 좋다 

조건 표현식에서 값에 float와 int가 섞여있으면 조건표현식의 자료형은 float가 된다 
(i > 0 ? i : f)여기서 i가 int f가 float고 i가 0보다 큰 경우에 반환되는 i의 자료형의 float이다 


chap6 Loops

반복문은 어느 문들을 반복해서 실행하는데 반복마다 조건식이 필요하다 조건식이 0이 아니면 반복을 지속한다
C의 반복문에는 while, do while, for문이 있다 

while문
C에서 while문은 가장 간단하고 기본적인 반복문이다 형태는 다음과 같다 
ex) while(expression) statement
표현식 내부네은 조건식이 들어가는 경우가 많고 statement는 반복하는 대상이다 
while문이 시작할 때 조건식을 먼저 보고 그 값이 0이 아니면 반복 대상을 실행한다 그리고 이것을 반복한다 
반목 대상을 중괄호로 감싸면 반복 대상의 길이에는 제한이 없어진다 

무한반복(Infinite Loops)
while문의 조건식이 항상 0이 아닌 수가 나오면 while문은 종료가 되지 않는다 때때로 C프로그래머들은 의도적으로 
무한반복문을 만든다 
ex) while(1) .... 이렇게 무한으로 반복을 돌게 만들면 반복을 빠져나오는 문을 만나지 않는이상 계속 반복된다(break, goto, return)

do while문
do문은 while문과 밀접하게 연관되어있다  형태는 다음과 같다
ex) do statement while(expression);
여기서 statement문이 먼저 한번 실행되고 그 다음에 조건식을 계산한다 조건식이 0이 아니면 statement문을
실행하고 이를 반복한다 do문은 이 조건식이 0이 나오면 종료된다

for문
for문은 카운팅을 하는 반복문에서 이상적인 형태이다 for문의 형태는 다음과 같다
ex) for(expr1; expr2; expr3) statement
for문을 while문으로 바꾸면 다음과 같다
ex) expr1;  while(expr2) { statement  expr3;} 
이 패턴을 보면 expr1은 초기값을 설정하고 한번만 실행된다 expr2는 반복의 종료조건이 들어가고 expr3은
각 루프의 끝에 실행되는 연산을 의미한다  
expr1과 expr3은 필수로 들어가야 하는 식은 아니다 그리고 expr3식에는 보통 가감산 연산을 주로 사용한다(++ --)

for문의 특성(idioms)
for문은 숫자를 증가시키거나 감소시키는 반복에서 사용하기 좋은 반복문이다 n번 반복하는 형태는 다음과 같다
0부터 n-1까지 반복
for(i = 0; i < n; i++) ...
0부터 n까지 반복 
for(i = 0; i <=n; i++)...
n-1부터 0까지 반복
for(i = n -1; i >= 0; i++)..
n부터 1까지 반복
for(i = n; i >0; i++)...
이 형태를 복사해서 사용하면 에러의 발생을 줄일 수 있다
증가 반복에서는 < or <=연산을 사용하고  감소 반복에서는 > or >=연산을 사용한다
> < >= <=대신 ==연산을 사용하려면 초기 설정이 필요하다 

for문에서 표현식 생략
for문은 생각보다 유연한 구문이다 for문에서 3개의 표현식을 모두 넣을 필요는 없다 첫 표현식을 제외할 떄느느 
초기값을 반복 전에 설정하면 된다
ex) i = 10;   for( ; i >0; --i){  }
세번째 표현식을 생략할 때는 반복 내용에 두번째 표현식이 0이 나오게 할 수 있는 연산이 필요하다
ex) for(i = 10; i > 0; ){  printf("%d", i--);}
두번쨰 표현식이 생략되면 반복이 종료되지 않아서 무한루프가 된다

C99에서의 for문
C99에서 첫 표현식을 변수의 선언으로 대체할 수 있다 
ex) for(int i = 0; i < n; i++)
이미 변수가 선언되어있으면 해당 변수는 반복문 안에서만 사용되는 변수가 된다 이렇게 생성된 변수는
반복문 밖에서는 접근할 수 없다 이렇게 반복문 내에서 변수를 선언하면 이해하기가 쉽다 하나 이상의 변수도 선언이 가능하다
ex) for(int i = 0, j = 0; i <n; i++){

쉼표 연산자 (comma operator)
첫번쨰 표현식, 세 번쨰 표현식에서 다양한 변수를 조정할 때 쉼표 연산자를 사용한다 쉼표연산자의 형태는 다음과 같다
ex)  expr1 , expr2
expr1과 expr2는 어느 표현식이든 가능하다 expr1이 먼저 계산되고 그 값은 버려진다 
그 다음에 expr2가 계산되고 그값이 전체 표현식의 값이 된다 그렇게 때문에 expr1에는 부과효과를 줘야한다
ex) i = 1 j = 5 ;   ++i, i + j 가 있을 때  i가 ++돼서 2가 되고 5를 더해서 해당 표현식은 7이 된다
쉼표 연산자의 우선순위는 다른 연산자들보다 낮다 
쉼표 연산자는 C에서는 한개의 표현식을 원하지만 두개나 그 이상의 표현식을 사용하고 싶을 때 쉼표 연산자를 사용하면된다
ex)for(sum = 0, i = 1; i <= N; i++){

반복문 종료 (Exiting from a Loop)
반복문을 빠져나올때는 반목 내용문을 실행하기 전에 표현식을 통해 하거나 반복내용 실행 후 표현식을 통해 하였다
break문을 사용하면 중간에 반복을 빠져나올 수 있다 continue와 got문도 있는데 continue는 반복은 종료되지 않고
현재 실행중인 반복 내용을 스킵한다 goto는 다른 문으로 이동을 시켜준다 goto는 거의 사용하지 않는다 

break문
switch에서도 break문을 사용하였었는데 switch에서와 마찬가지로 break문은 for , while , do문 밖으로 이동시켜준다
break는 반복내용 시작과 끝쪽보다는 중앙쪽에 놓는것이 좋다 , for ,while, do, switch문이 중첩되어 있다면
break는 한 개의 구문만 빠져나올 수 있게 한다 
ex) while() {  switch() { ... break}}  switch문은 빠져나오지만 while문은 빠져나오지 못한다 

continue문
continue문은 반복을 빠져나오는 것은 아니다 break문과 유사하지만 break문은 반복을 완전히 빠져나오지만 continue는
반복문을 빠져나가지 못하고 반복의 처음으로 되돌아간다 그리고 break문은 switch문에서도 사용이 가능하지만 continue문은 반복에서만 사용이 가능하다 


goto문
break와 continue문은 다른 지점의 문으로 점프를 시켜주는데 두 문은 제한적이다 break는 반복문 끝을 넘어선 지점이고
continue는 반복의 끝 전 지점이다 반면에 goto문은 함수 라벨로  어느 문으로든지 이동이 가능하다  (C99에서는 
가변길이의 배열 선언을 우회할 수 없다는 제약이 있다)
label의 선언은 다음과 같이 한다
identifier : statement
한개 이상의 라벨이 있을 떄 goto문은 다음과 같이 사용한다
goto identifier;
goto문을 실행하면 identifier을 선언한 곳으로 문을 이동한다 
 break, continue , return등은 근본적으로 제한이 있기 때문에 goto문은 가끔 필요하다 

NUll문
Null문은 세미콜론을제외하고는 아무것도 없는 문이다 예는 다음과 같다
ex) i = 0;  ;  j = 1;
Null문은 내용이 비어있는 반복문을 사용할 떄 주로 사용된다 
null문은 간결하지만 일반적으로 효율적이지는 않다 
if, while, for문 뒤에 세미콜론을 놓으면 Null문이 만들어진다  
if문 뒤에 세미콜론을 넣으면 조건식에 관련없이 같은 동작을 하게된다 

while문 안에 continue가 있는 경우 for문으로 변환을 할 수가 없다 
무한루프를 만들 때 프로그래머들은 오래된 컴파일러에서 더 호율적이여서 for(;;)를 사용했다
while루프는 반복을 돌떄마다 1 조건식을 체크하기 때문이다 현대 컴파일러는 차이가 없다 
goto문은 나쁘지는 않지만 보통 goto문보다 더 나은 대안이 있다  그리고 goto문을 사용하면
스파게티 코드가 되기 쉬운데 스파게티 코드는 읽고 이해하기가 어렵다 goto문을 쓰면 앞뒤로 점프해서 읽기가 어려워진다 
null문은 어디든지 사용할 수 있지만 실직적으로 사용은 루프의 몸체가 비었다는 것을 나타내는 한가지 용도로만 한다 

chap7  Basoc Types

integer 타입
C는 근본적으로 두 종류의 숫자 타입을 제공한다 integer와 floating타입인데 integer타입은 모든 숫자이고 
floating type은 분수를 가질 수 있다 integer은 signed와 unsinged로 나뉜다 
가장 왼쪽의 비트는 sign bit이고 이 비트가 0이면 0이거나 양수이고 1이면 음수이다 